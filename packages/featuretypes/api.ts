// tslint:disable
/**
 * GeoServer Feature Types
 * A feature type is a vector based spatial resource or data set that originates from a data store. In some cases, such as with a shapefile, a feature type has a one-to-one relationship with its data store. In other cases, such as PostGIS, the relationship of feature type to data store is many-to-one, feature types corresponding to a table in the database.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: geoserver-users@sourceforge.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface FeatureTypeInfo
 */
export interface FeatureTypeInfo {
    /**
     * The name of the resource. This name corresponds to the \"published\" name of the resource.
     * @type {string}
     * @memberof FeatureTypeInfo
     */
    name?: string;
    /**
     * The native name of the resource. This name corresponds to the physical resource that feature type is derived from -- a shapefile name, a database table, etc...
     * @type {string}
     * @memberof FeatureTypeInfo
     */
    nativeName?: string;
    /**
     * 
     * @type {FeatureTypeInfoNamespace}
     * @memberof FeatureTypeInfo
     */
    namespace?: FeatureTypeInfoNamespace;
    /**
     * The title of the resource. This is usually something that is meant to be displayed in a user interface.
     * @type {string}
     * @memberof FeatureTypeInfo
     */
    title?: string;
    /**
     * A description of the resource. This is usually something that is meant to be displayed in a user interface.
     * @type {string}
     * @memberof FeatureTypeInfo
     */
    _abstract?: string;
    /**
     * 
     * @type {FeatureTypeInfoKeywords}
     * @memberof FeatureTypeInfo
     */
    keywords?: FeatureTypeInfoKeywords;
    /**
     * 
     * @type {FeatureTypeInfoMetadatalinks}
     * @memberof FeatureTypeInfo
     */
    metadatalinks?: FeatureTypeInfoMetadatalinks;
    /**
     * 
     * @type {FeatureTypeInfoDataLinks}
     * @memberof FeatureTypeInfo
     */
    dataLinks?: FeatureTypeInfoDataLinks;
    /**
     * The native coordinate reference system object of the resource.
     * @type {string}
     * @memberof FeatureTypeInfo
     */
    nativeCRS?: string;
    /**
     * Returns the identifier of coordinate reference system of the resource.
     * @type {string}
     * @memberof FeatureTypeInfo
     */
    srs?: string;
    /**
     * 
     * @type {FeatureTypeInfoNativeBoundingBox}
     * @memberof FeatureTypeInfo
     */
    nativeBoundingBox?: FeatureTypeInfoNativeBoundingBox;
    /**
     * 
     * @type {FeatureTypeInfoLatLonBoundingBox}
     * @memberof FeatureTypeInfo
     */
    latLonBoundingBox?: FeatureTypeInfoLatLonBoundingBox;
    /**
     * A list of key/value metadata pairs.
     * @type {Array<MetadataEntry>}
     * @memberof FeatureTypeInfo
     */
    metadata?: Array<MetadataEntry>;
    /**
     * 
     * @type {FeatureTypeInfoStore}
     * @memberof FeatureTypeInfo
     */
    store?: FeatureTypeInfoStore;
    /**
     * The ECQL string used as default feature type filter
     * @type {string}
     * @memberof FeatureTypeInfo
     */
    cqlFilter?: string;
    /**
     * A cap on the number of features that a query against this type can return.
     * @type {number}
     * @memberof FeatureTypeInfo
     */
    maxFeatures?: number;
    /**
     * The number of decimal places to use when encoding floating point numbers from data of this feature type.
     * @type {number}
     * @memberof FeatureTypeInfo
     */
    numDecimals?: number;
    /**
     * 
     * @type {FeatureTypeInfoResponseSRS}
     * @memberof FeatureTypeInfo
     */
    responseSRS?: FeatureTypeInfoResponseSRS;
    /**
     * True if this feature type info is overriding the WFS global SRS list
     * @type {boolean}
     * @memberof FeatureTypeInfo
     */
    overridingServiceSRS?: boolean;
    /**
     * True if this feature type info is overriding the counting of numberMatched.
     * @type {boolean}
     * @memberof FeatureTypeInfo
     */
    skipNumberMatched?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FeatureTypeInfo
     */
    circularArcPresent?: boolean;
    /**
     * Tolerance used to linearize this feature type, as an absolute value expressed in the geometries own CRS
     * @type {number}
     * @memberof FeatureTypeInfo
     */
    linearizationTolerance?: number;
    /**
     * 
     * @type {FeatureTypeInfoAttributes}
     * @memberof FeatureTypeInfo
     */
    attributes?: FeatureTypeInfoAttributes;
}
/**
 * Wrapper for the derived set of attributes for the feature type.
 * @export
 * @interface FeatureTypeInfoAttributes
 */
export interface FeatureTypeInfoAttributes {
    /**
     * The derived set of attributes for the feature type.
     * @type {Array<FeatureTypeInfoAttributesAttribute>}
     * @memberof FeatureTypeInfoAttributes
     */
    attribute?: Array<FeatureTypeInfoAttributesAttribute>;
}
/**
 * A single attribute
 * @export
 * @interface FeatureTypeInfoAttributesAttribute
 */
export interface FeatureTypeInfoAttributesAttribute {
    /**
     * Name of the attribute.
     * @type {string}
     * @memberof FeatureTypeInfoAttributesAttribute
     */
    name?: string;
    /**
     * Minimum number of occurrences of the attribute.
     * @type {number}
     * @memberof FeatureTypeInfoAttributesAttribute
     */
    minOccurs?: number;
    /**
     * Maximum number of occurrences of the attribute.
     * @type {number}
     * @memberof FeatureTypeInfoAttributesAttribute
     */
    maxOccurs?: number;
    /**
     * Flag indicating if null is an acceptable value for the attribute.
     * @type {boolean}
     * @memberof FeatureTypeInfoAttributesAttribute
     */
    nillable?: boolean;
    /**
     * The java class that values of this attribute are bound to.
     * @type {string}
     * @memberof FeatureTypeInfoAttributesAttribute
     */
    binding?: string;
    /**
     * Returns the length of this attribute. It\'s usually non null only for string and numeric types\"
     * @type {number}
     * @memberof FeatureTypeInfoAttributesAttribute
     */
    length?: number;
}
/**
 * Wraps a collection of data links for the resource.
 * @export
 * @interface FeatureTypeInfoDataLinks
 */
export interface FeatureTypeInfoDataLinks {
    /**
     * A collection of data links for the resource.
     * @type {Array<FeatureTypeInfoDataLinksMetadataLink>}
     * @memberof FeatureTypeInfoDataLinks
     */
    metadataLink?: Array<FeatureTypeInfoDataLinksMetadataLink>;
}
/**
 * 
 * @export
 * @interface FeatureTypeInfoDataLinksMetadataLink
 */
export interface FeatureTypeInfoDataLinksMetadataLink {
    /**
     * The MIME type
     * @type {string}
     * @memberof FeatureTypeInfoDataLinksMetadataLink
     */
    type?: string;
    /**
     * The link URL
     * @type {string}
     * @memberof FeatureTypeInfoDataLinksMetadataLink
     */
    content?: string;
}
/**
 * A collection of keywords associated with the resource.
 * @export
 * @interface FeatureTypeInfoKeywords
 */
export interface FeatureTypeInfoKeywords {
    /**
     * List of keyword values with internationalization and vocabulary
     * @type {Array<string>}
     * @memberof FeatureTypeInfoKeywords
     */
    string?: Array<string>;
}
/**
 * The bounds of the resource in lat / lon. This value represents a \"fixed value\" and is not calculated on the underlying dataset.
 * @export
 * @interface FeatureTypeInfoLatLonBoundingBox
 */
export interface FeatureTypeInfoLatLonBoundingBox {
    /**
     * The min x coordinate
     * @type {number}
     * @memberof FeatureTypeInfoLatLonBoundingBox
     */
    minx?: number;
    /**
     * The max x coordinate
     * @type {number}
     * @memberof FeatureTypeInfoLatLonBoundingBox
     */
    maxx?: number;
    /**
     * The min y coordinate
     * @type {number}
     * @memberof FeatureTypeInfoLatLonBoundingBox
     */
    miny?: number;
    /**
     * The max y coordinate
     * @type {number}
     * @memberof FeatureTypeInfoLatLonBoundingBox
     */
    maxy?: number;
    /**
     * The coordinate reference system object of the bounding box.
     * @type {string}
     * @memberof FeatureTypeInfoLatLonBoundingBox
     */
    crs?: string;
}
/**
 * Wraps a collection of metadata links for the resource.
 * @export
 * @interface FeatureTypeInfoMetadatalinks
 */
export interface FeatureTypeInfoMetadatalinks {
    /**
     * A collection of metadata links for the resource.
     * @type {Array<FeatureTypeInfoMetadatalinksMetadataLink>}
     * @memberof FeatureTypeInfoMetadatalinks
     */
    metadataLink?: Array<FeatureTypeInfoMetadatalinksMetadataLink>;
}
/**
 * 
 * @export
 * @interface FeatureTypeInfoMetadatalinksMetadataLink
 */
export interface FeatureTypeInfoMetadatalinksMetadataLink {
    /**
     * The MIME type
     * @type {string}
     * @memberof FeatureTypeInfoMetadatalinksMetadataLink
     */
    type?: string;
    /**
     * The type of metadata, e.g. \"FGDC\"
     * @type {string}
     * @memberof FeatureTypeInfoMetadatalinksMetadataLink
     */
    metadataType?: string;
    /**
     * The link URL
     * @type {string}
     * @memberof FeatureTypeInfoMetadatalinksMetadataLink
     */
    content?: string;
}
/**
 * The namespace URI of the resource. Example would be an application schema namespace URI.
 * @export
 * @interface FeatureTypeInfoNamespace
 */
export interface FeatureTypeInfoNamespace {
    /**
     * The name of the namespace.
     * @type {string}
     * @memberof FeatureTypeInfoNamespace
     */
    name?: string;
    /**
     * URL to the namespace.
     * @type {string}
     * @memberof FeatureTypeInfoNamespace
     */
    href?: string;
}
/**
 * Returns the bounds of the resource in its declared CRS.
 * @export
 * @interface FeatureTypeInfoNativeBoundingBox
 */
export interface FeatureTypeInfoNativeBoundingBox {
    /**
     * The min x coordinate
     * @type {number}
     * @memberof FeatureTypeInfoNativeBoundingBox
     */
    minx?: number;
    /**
     * The max x coordinate
     * @type {number}
     * @memberof FeatureTypeInfoNativeBoundingBox
     */
    maxx?: number;
    /**
     * The min y coordinate
     * @type {number}
     * @memberof FeatureTypeInfoNativeBoundingBox
     */
    miny?: number;
    /**
     * The max y coordinate
     * @type {number}
     * @memberof FeatureTypeInfoNativeBoundingBox
     */
    maxy?: number;
    /**
     * The coordinate reference system object of the bounding box.
     * @type {string}
     * @memberof FeatureTypeInfoNativeBoundingBox
     */
    crs?: string;
}
/**
 * The SRSs that the WFS service will advertise in the capabilities document for this feature type (overriding the global WFS settings).
 * @export
 * @interface FeatureTypeInfoResponseSRS
 */
export interface FeatureTypeInfoResponseSRS {
    /**
     * The value of the srs
     * @type {string}
     * @memberof FeatureTypeInfoResponseSRS
     */
    string?: string;
}
/**
 * The store the resource is a part of.
 * @export
 * @interface FeatureTypeInfoStore
 */
export interface FeatureTypeInfoStore {
    /**
     * The class of the store
     * @type {string}
     * @memberof FeatureTypeInfoStore
     */
    _class?: string;
    /**
     * The name of the store
     * @type {string}
     * @memberof FeatureTypeInfoStore
     */
    name?: string;
    /**
     * URL to the data store
     * @type {string}
     * @memberof FeatureTypeInfoStore
     */
    href?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {InlineResponse200FeatureTypes}
     * @memberof InlineResponse200
     */
    featureTypes?: InlineResponse200FeatureTypes;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {FeatureTypeInfo}
     * @memberof InlineResponse2001
     */
    featureType?: FeatureTypeInfo;
}
/**
 * 
 * @export
 * @interface InlineResponse200FeatureTypes
 */
export interface InlineResponse200FeatureTypes {
    /**
     * 
     * @type {Array<InlineResponse200FeatureTypesFeatureType>}
     * @memberof InlineResponse200FeatureTypes
     */
    featureType?: Array<InlineResponse200FeatureTypesFeatureType>;
}
/**
 * 
 * @export
 * @interface InlineResponse200FeatureTypesFeatureType
 */
export interface InlineResponse200FeatureTypesFeatureType {
    /**
     * The Name
     * @type {string}
     * @memberof InlineResponse200FeatureTypesFeatureType
     */
    name?: string;
    /**
     * The URL
     * @type {string}
     * @memberof InlineResponse200FeatureTypesFeatureType
     */
    link?: string;
}
/**
 * 
 * @export
 * @interface MetadataEntry
 */
export interface MetadataEntry {
    /**
     * Key used for metadata entry, additional keys are added over time
     * @type {string}
     * @memberof MetadataEntry
     */
    key?: MetadataEntryKeyEnum;
    /**
     * Text value for provided key Valid text depends on key used. Example  {\'@key\'=\'cachingEnabled\',\'$\'=\'true\'}.
     * @type {string}
     * @memberof MetadataEntry
     */
    value?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum MetadataEntryKeyEnum {
    RegionateStrategy = 'regionateStrategy',
    RegionateFeatureLimit = 'regionateFeatureLimit',
    CacheAgeMax = 'cacheAgeMax',
    CachingEnabled = 'cachingEnabled',
    RegionateAttribute = 'regionateAttribute',
    IndexingEnabled = 'indexingEnabled',
    DirName = 'dirName'
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a feature type (optionally recursively deleting layers).
         * @param {string} workspaceName The name of the workspace
         * @param {string} storeName The name of the datastore
         * @param {string} featureTypeName The name of the feature type
         * @param {boolean} [recurse] Recursively deletes all layers referenced by the specified featuretype. Allowed values for this parameter are true or false. The default value is false. A request with \&#39;recurse&#x3D;false\&#39; will fail if any layers reference the featuretype.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeatureType: async (workspaceName: string, storeName: string, featureTypeName: string, recurse?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceName' is not null or undefined
            if (workspaceName === null || workspaceName === undefined) {
                throw new RequiredError('workspaceName','Required parameter workspaceName was null or undefined when calling deleteFeatureType.');
            }
            // verify required parameter 'storeName' is not null or undefined
            if (storeName === null || storeName === undefined) {
                throw new RequiredError('storeName','Required parameter storeName was null or undefined when calling deleteFeatureType.');
            }
            // verify required parameter 'featureTypeName' is not null or undefined
            if (featureTypeName === null || featureTypeName === undefined) {
                throw new RequiredError('featureTypeName','Required parameter featureTypeName was null or undefined when calling deleteFeatureType.');
            }
            const localVarPath = `/workspaces/{workspaceName}/datastores/{storeName}/featuretypes/{featureTypeName}`
                .replace(`{${"workspaceName"}}`, encodeURIComponent(String(workspaceName)))
                .replace(`{${"storeName"}}`, encodeURIComponent(String(storeName)))
                .replace(`{${"featureTypeName"}}`, encodeURIComponent(String(featureTypeName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (recurse !== undefined) {
                localVarQueryParameter['recurse'] = recurse;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a feature type in the default data store for the workspace (optionally recursively deleting layers).
         * @param {string} workspaceName The name of the workspace
         * @param {string} featureTypeName The name of the feature type
         * @param {boolean} [recurse] Recursively deletes all layers referenced by the specified featuretype. Allowed values for this parameter are true or false. The default value is false. A request with \&#39;recurse&#x3D;false\&#39; will fail if any layers reference the featuretype.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeatureType_1: async (workspaceName: string, featureTypeName: string, recurse?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceName' is not null or undefined
            if (workspaceName === null || workspaceName === undefined) {
                throw new RequiredError('workspaceName','Required parameter workspaceName was null or undefined when calling deleteFeatureType_1.');
            }
            // verify required parameter 'featureTypeName' is not null or undefined
            if (featureTypeName === null || featureTypeName === undefined) {
                throw new RequiredError('featureTypeName','Required parameter featureTypeName was null or undefined when calling deleteFeatureType_1.');
            }
            const localVarPath = `/workspaces/{workspaceName}/featuretypes/{featureTypeName}`
                .replace(`{${"workspaceName"}}`, encodeURIComponent(String(workspaceName)))
                .replace(`{${"featureTypeName"}}`, encodeURIComponent(String(featureTypeName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (recurse !== undefined) {
                localVarQueryParameter['recurse'] = recurse;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalid.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeatureTypes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/workspaces/{workspaceName}/datastores/{storeName}/featuretypes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalid.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeatureTypes_2: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/workspaces/{workspaceName}/featuretypes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an individual feature type
         * @param {string} workspaceName The name of the workspace
         * @param {string} storeName The name of the datastore
         * @param {string} featureTypeName The name of the feature type
         * @param {boolean} [quietOnNotFound] Prevents logging an Exception when the feature type is not present. Note that 404 status code will be returned anyway. Defaults to \&quot;false\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureType: async (workspaceName: string, storeName: string, featureTypeName: string, quietOnNotFound?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceName' is not null or undefined
            if (workspaceName === null || workspaceName === undefined) {
                throw new RequiredError('workspaceName','Required parameter workspaceName was null or undefined when calling getFeatureType.');
            }
            // verify required parameter 'storeName' is not null or undefined
            if (storeName === null || storeName === undefined) {
                throw new RequiredError('storeName','Required parameter storeName was null or undefined when calling getFeatureType.');
            }
            // verify required parameter 'featureTypeName' is not null or undefined
            if (featureTypeName === null || featureTypeName === undefined) {
                throw new RequiredError('featureTypeName','Required parameter featureTypeName was null or undefined when calling getFeatureType.');
            }
            const localVarPath = `/workspaces/{workspaceName}/datastores/{storeName}/featuretypes/{featureTypeName}`
                .replace(`{${"workspaceName"}}`, encodeURIComponent(String(workspaceName)))
                .replace(`{${"storeName"}}`, encodeURIComponent(String(storeName)))
                .replace(`{${"featureTypeName"}}`, encodeURIComponent(String(featureTypeName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (quietOnNotFound !== undefined) {
                localVarQueryParameter['quietOnNotFound'] = quietOnNotFound;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an individual feature type in the default data store for the workspace
         * @param {string} workspaceName The name of the workspace
         * @param {string} featureTypeName The name of the feature type
         * @param {boolean} [quietOnNotFound] Prevents logging an Exception when the feature type is not present. Note that 404 status code will be returned anyway. Defaults to \&quot;false\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureType_3: async (workspaceName: string, featureTypeName: string, quietOnNotFound?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceName' is not null or undefined
            if (workspaceName === null || workspaceName === undefined) {
                throw new RequiredError('workspaceName','Required parameter workspaceName was null or undefined when calling getFeatureType_3.');
            }
            // verify required parameter 'featureTypeName' is not null or undefined
            if (featureTypeName === null || featureTypeName === undefined) {
                throw new RequiredError('featureTypeName','Required parameter featureTypeName was null or undefined when calling getFeatureType_3.');
            }
            const localVarPath = `/workspaces/{workspaceName}/featuretypes/{featureTypeName}`
                .replace(`{${"workspaceName"}}`, encodeURIComponent(String(workspaceName)))
                .replace(`{${"featureTypeName"}}`, encodeURIComponent(String(featureTypeName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (quietOnNotFound !== undefined) {
                localVarQueryParameter['quietOnNotFound'] = quietOnNotFound;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of feature types for the workspace and datastore. Use the \"Accept:\" header to specify format or append an extension to the endpoint (example \"/featuretypes.xml\" for XML) 
         * @param {string} workspaceName The name of the workspace
         * @param {string} storeName The name of the datastore
         * @param {'configured' | 'available' | 'available_with_geom' | 'all'} [list] The list parameter is used to control the category of feature types that are returned. Must be one of \&quot;configured\&quot;, \&quot;available\&quot;, \&quot;available_with_geom\&quot;, \&quot;all\&quot; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureTypes: async (workspaceName: string, storeName: string, list?: 'configured' | 'available' | 'available_with_geom' | 'all', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceName' is not null or undefined
            if (workspaceName === null || workspaceName === undefined) {
                throw new RequiredError('workspaceName','Required parameter workspaceName was null or undefined when calling getFeatureTypes.');
            }
            // verify required parameter 'storeName' is not null or undefined
            if (storeName === null || storeName === undefined) {
                throw new RequiredError('storeName','Required parameter storeName was null or undefined when calling getFeatureTypes.');
            }
            const localVarPath = `/workspaces/{workspaceName}/datastores/{storeName}/featuretypes`
                .replace(`{${"workspaceName"}}`, encodeURIComponent(String(workspaceName)))
                .replace(`{${"storeName"}}`, encodeURIComponent(String(storeName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (list !== undefined) {
                localVarQueryParameter['list'] = list;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all feature types for all datastores in the workspace. Use the \"Accept:\" header to specify format or append an extension to the endpoint (example \"/featuretypes.xml\" for XML) 
         * @param {string} workspaceName The name of the workspace
         * @param {'configured' | 'available' | 'available_with_geom' | 'all'} [list] The list parameter is used to control the category of feature types that are returned. Must be one of \&quot;configured\&quot;, \&quot;available\&quot;, \&quot;available_with_geom\&quot;, \&quot;all\&quot; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureTypes_4: async (workspaceName: string, list?: 'configured' | 'available' | 'available_with_geom' | 'all', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceName' is not null or undefined
            if (workspaceName === null || workspaceName === undefined) {
                throw new RequiredError('workspaceName','Required parameter workspaceName was null or undefined when calling getFeatureTypes_4.');
            }
            const localVarPath = `/workspaces/{workspaceName}/featuretypes`
                .replace(`{${"workspaceName"}}`, encodeURIComponent(String(workspaceName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (list !== undefined) {
                localVarQueryParameter['list'] = list;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalid. Use POST on the /featuretypes endpoint to add a new feature type, or PUT on an individual feature type to edit that type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFeatureType: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/workspaces/{workspaceName}/datastores/{storeName}/featuretypes/{featureTypeName}`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalid. Use POST on the /featuretypes endpoint to add a new feature type, or PUT on an individual feature type to edit that type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFeatureType_5: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/workspaces/{workspaceName}/featuretypes/{featureTypeName}`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new feature type. Note -  when creating a new feature type via POST, if no underlying dataset with the specified name exists an attempt will be made to create it. This will work only in cases where the underlying data format supports the creation of new types (such as a database). When creating a feature type in this manner the client should include all attribute information in the feature type representation. 
         * @param {string} workspaceName The name of the workspace
         * @param {string} storeName The name of the datastore
         * @param {FeatureTypeInfo} featureType The body of the feature type to POST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFeatureTypes: async (workspaceName: string, storeName: string, featureType: FeatureTypeInfo, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceName' is not null or undefined
            if (workspaceName === null || workspaceName === undefined) {
                throw new RequiredError('workspaceName','Required parameter workspaceName was null or undefined when calling postFeatureTypes.');
            }
            // verify required parameter 'storeName' is not null or undefined
            if (storeName === null || storeName === undefined) {
                throw new RequiredError('storeName','Required parameter storeName was null or undefined when calling postFeatureTypes.');
            }
            // verify required parameter 'featureType' is not null or undefined
            if (featureType === null || featureType === undefined) {
                throw new RequiredError('featureType','Required parameter featureType was null or undefined when calling postFeatureTypes.');
            }
            const localVarPath = `/workspaces/{workspaceName}/datastores/{storeName}/featuretypes`
                .replace(`{${"workspaceName"}}`, encodeURIComponent(String(workspaceName)))
                .replace(`{${"storeName"}}`, encodeURIComponent(String(storeName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/xml';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof featureType !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(featureType !== undefined ? featureType : {}) : (featureType || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new feature type, the feature type definition needs to reference a store. Note -  when creating a new feature type via POST, if no underlying dataset with the specified name exists an attempt will be made to create it. This will work only in cases where the underlying data format supports the creation of new types (such as a database). When creating a feature type in this manner the client should include all attribute information in the feature type representation. 
         * @param {string} workspaceName The name of the workspace
         * @param {FeatureTypeInfo} featureType The body of the feature type to POST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFeatureTypes_6: async (workspaceName: string, featureType: FeatureTypeInfo, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceName' is not null or undefined
            if (workspaceName === null || workspaceName === undefined) {
                throw new RequiredError('workspaceName','Required parameter workspaceName was null or undefined when calling postFeatureTypes_6.');
            }
            // verify required parameter 'featureType' is not null or undefined
            if (featureType === null || featureType === undefined) {
                throw new RequiredError('featureType','Required parameter featureType was null or undefined when calling postFeatureTypes_6.');
            }
            const localVarPath = `/workspaces/{workspaceName}/featuretypes`
                .replace(`{${"workspaceName"}}`, encodeURIComponent(String(workspaceName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/xml';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof featureType !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(featureType !== undefined ? featureType : {}) : (featureType || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an individual feature type
         * @param {string} workspaceName The name of the workspace
         * @param {string} storeName The name of the datastore
         * @param {string} featureTypeName The name of the feature type
         * @param {FeatureTypeInfo} featureType The body of the feature type to POST
         * @param {Array<'nativebbox' | 'latlonbbox'>} [recalculate] Specifies whether to recalculate any bounding boxes for a feature type. Some properties of feature types are automatically recalculated when necessary. In particular, the native bounding box is recalculated when the projection or projection policy are changed, and the lat/lon bounding box is recalculated when the native bounding box is recalculated, or when a new native bounding box is explicitly provided in the request. (The native and lat/lon bounding boxes are not automatically recalculated when they are explicitly included in the request.) In addition, the client may explicitly request a fixed set of fields to calculate, by including a comma-separated list of their names in the recalculate parameter.  The empty parameter \&#39;recalculate&#x3D;\&#39; is useful avoid slow recalculation when operating against large datasets as \&#39;recalculate&#x3D;\&#39; avoids calculating any fields, regardless of any changes to projection, projection policy, etc. The nativebbox parameter \&#39;recalculate&#x3D;nativebbox\&#39; is used recalculates the native bounding box, while avoiding recalculating the lat/lon bounding box. Recalculate parameters can be used in together - \&#39;recalculate&#x3D;nativebbox,latlonbbox\&#39; can be used after a bulk import to recalculate both the native bounding box and the lat/lon bounding box.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFeatureType: async (workspaceName: string, storeName: string, featureTypeName: string, featureType: FeatureTypeInfo, recalculate?: Array<'nativebbox' | 'latlonbbox'>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceName' is not null or undefined
            if (workspaceName === null || workspaceName === undefined) {
                throw new RequiredError('workspaceName','Required parameter workspaceName was null or undefined when calling putFeatureType.');
            }
            // verify required parameter 'storeName' is not null or undefined
            if (storeName === null || storeName === undefined) {
                throw new RequiredError('storeName','Required parameter storeName was null or undefined when calling putFeatureType.');
            }
            // verify required parameter 'featureTypeName' is not null or undefined
            if (featureTypeName === null || featureTypeName === undefined) {
                throw new RequiredError('featureTypeName','Required parameter featureTypeName was null or undefined when calling putFeatureType.');
            }
            // verify required parameter 'featureType' is not null or undefined
            if (featureType === null || featureType === undefined) {
                throw new RequiredError('featureType','Required parameter featureType was null or undefined when calling putFeatureType.');
            }
            const localVarPath = `/workspaces/{workspaceName}/datastores/{storeName}/featuretypes/{featureTypeName}`
                .replace(`{${"workspaceName"}}`, encodeURIComponent(String(workspaceName)))
                .replace(`{${"storeName"}}`, encodeURIComponent(String(storeName)))
                .replace(`{${"featureTypeName"}}`, encodeURIComponent(String(featureTypeName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (recalculate) {
                localVarQueryParameter['recalculate'] = recalculate.join(COLLECTION_FORMATS.csv);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/xml';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof featureType !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(featureType !== undefined ? featureType : {}) : (featureType || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an individual feature type in the default data store for the workspace
         * @param {string} workspaceName The name of the workspace
         * @param {string} featureTypeName The name of the feature type
         * @param {FeatureTypeInfo} featureType The body of the feature type to POST
         * @param {Array<'nativebbox' | 'latlonbbox'>} [recalculate] Specifies whether to recalculate any bounding boxes for a feature type. Some properties of feature types are automatically recalculated when necessary. In particular, the native bounding box is recalculated when the projection or projection policy are changed, and the lat/lon bounding box is recalculated when the native bounding box is recalculated, or when a new native bounding box is explicitly provided in the request. (The native and lat/lon bounding boxes are not automatically recalculated when they are explicitly included in the request.) In addition, the client may explicitly request a fixed set of fields to calculate, by including a comma-separated list of their names in the recalculate parameter.  The empty parameter \&#39;recalculate&#x3D;\&#39; is useful avoid slow recalculation when operating against large datasets as \&#39;recalculate&#x3D;\&#39; avoids calculating any fields, regardless of any changes to projection, projection policy, etc. The nativebbox parameter \&#39;recalculate&#x3D;nativebbox\&#39; is used recalculates the native bounding box, while avoiding recalculating the lat/lon bounding box. Recalculate parameters can be used in together - \&#39;recalculate&#x3D;nativebbox,latlonbbox\&#39; can be used after a bulk import to recalculate both the native bounding box and the lat/lon bounding box.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFeatureType_7: async (workspaceName: string, featureTypeName: string, featureType: FeatureTypeInfo, recalculate?: Array<'nativebbox' | 'latlonbbox'>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceName' is not null or undefined
            if (workspaceName === null || workspaceName === undefined) {
                throw new RequiredError('workspaceName','Required parameter workspaceName was null or undefined when calling putFeatureType_7.');
            }
            // verify required parameter 'featureTypeName' is not null or undefined
            if (featureTypeName === null || featureTypeName === undefined) {
                throw new RequiredError('featureTypeName','Required parameter featureTypeName was null or undefined when calling putFeatureType_7.');
            }
            // verify required parameter 'featureType' is not null or undefined
            if (featureType === null || featureType === undefined) {
                throw new RequiredError('featureType','Required parameter featureType was null or undefined when calling putFeatureType_7.');
            }
            const localVarPath = `/workspaces/{workspaceName}/featuretypes/{featureTypeName}`
                .replace(`{${"workspaceName"}}`, encodeURIComponent(String(workspaceName)))
                .replace(`{${"featureTypeName"}}`, encodeURIComponent(String(featureTypeName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (recalculate) {
                localVarQueryParameter['recalculate'] = recalculate.join(COLLECTION_FORMATS.csv);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/xml';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof featureType !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(featureType !== undefined ? featureType : {}) : (featureType || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalid. Use POST for adding a new feature type, or PUT on an individual feature type to edit that type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFeatureTypes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/workspaces/{workspaceName}/datastores/{storeName}/featuretypes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalid. Use POST for adding a new feature type, or PUT on an individual feature type to edit that type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFeatureTypes_8: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/workspaces/{workspaceName}/featuretypes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a feature type (optionally recursively deleting layers).
         * @param {string} workspaceName The name of the workspace
         * @param {string} storeName The name of the datastore
         * @param {string} featureTypeName The name of the feature type
         * @param {boolean} [recurse] Recursively deletes all layers referenced by the specified featuretype. Allowed values for this parameter are true or false. The default value is false. A request with \&#39;recurse&#x3D;false\&#39; will fail if any layers reference the featuretype.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFeatureType(workspaceName: string, storeName: string, featureTypeName: string, recurse?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).deleteFeatureType(workspaceName, storeName, featureTypeName, recurse, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a feature type in the default data store for the workspace (optionally recursively deleting layers).
         * @param {string} workspaceName The name of the workspace
         * @param {string} featureTypeName The name of the feature type
         * @param {boolean} [recurse] Recursively deletes all layers referenced by the specified featuretype. Allowed values for this parameter are true or false. The default value is false. A request with \&#39;recurse&#x3D;false\&#39; will fail if any layers reference the featuretype.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFeatureType_1(workspaceName: string, featureTypeName: string, recurse?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).deleteFeatureType_1(workspaceName, featureTypeName, recurse, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Invalid.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFeatureTypes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).deleteFeatureTypes(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Invalid.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFeatureTypes_2(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).deleteFeatureTypes_2(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get an individual feature type
         * @param {string} workspaceName The name of the workspace
         * @param {string} storeName The name of the datastore
         * @param {string} featureTypeName The name of the feature type
         * @param {boolean} [quietOnNotFound] Prevents logging an Exception when the feature type is not present. Note that 404 status code will be returned anyway. Defaults to \&quot;false\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureType(workspaceName: string, storeName: string, featureTypeName: string, quietOnNotFound?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getFeatureType(workspaceName, storeName, featureTypeName, quietOnNotFound, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get an individual feature type in the default data store for the workspace
         * @param {string} workspaceName The name of the workspace
         * @param {string} featureTypeName The name of the feature type
         * @param {boolean} [quietOnNotFound] Prevents logging an Exception when the feature type is not present. Note that 404 status code will be returned anyway. Defaults to \&quot;false\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureType_3(workspaceName: string, featureTypeName: string, quietOnNotFound?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getFeatureType_3(workspaceName, featureTypeName, quietOnNotFound, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a list of feature types for the workspace and datastore. Use the \"Accept:\" header to specify format or append an extension to the endpoint (example \"/featuretypes.xml\" for XML) 
         * @param {string} workspaceName The name of the workspace
         * @param {string} storeName The name of the datastore
         * @param {'configured' | 'available' | 'available_with_geom' | 'all'} [list] The list parameter is used to control the category of feature types that are returned. Must be one of \&quot;configured\&quot;, \&quot;available\&quot;, \&quot;available_with_geom\&quot;, \&quot;all\&quot; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureTypes(workspaceName: string, storeName: string, list?: 'configured' | 'available' | 'available_with_geom' | 'all', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getFeatureTypes(workspaceName, storeName, list, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a list of all feature types for all datastores in the workspace. Use the \"Accept:\" header to specify format or append an extension to the endpoint (example \"/featuretypes.xml\" for XML) 
         * @param {string} workspaceName The name of the workspace
         * @param {'configured' | 'available' | 'available_with_geom' | 'all'} [list] The list parameter is used to control the category of feature types that are returned. Must be one of \&quot;configured\&quot;, \&quot;available\&quot;, \&quot;available_with_geom\&quot;, \&quot;all\&quot; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureTypes_4(workspaceName: string, list?: 'configured' | 'available' | 'available_with_geom' | 'all', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getFeatureTypes_4(workspaceName, list, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Invalid. Use POST on the /featuretypes endpoint to add a new feature type, or PUT on an individual feature type to edit that type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFeatureType(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postFeatureType(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Invalid. Use POST on the /featuretypes endpoint to add a new feature type, or PUT on an individual feature type to edit that type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFeatureType_5(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postFeatureType_5(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new feature type. Note -  when creating a new feature type via POST, if no underlying dataset with the specified name exists an attempt will be made to create it. This will work only in cases where the underlying data format supports the creation of new types (such as a database). When creating a feature type in this manner the client should include all attribute information in the feature type representation. 
         * @param {string} workspaceName The name of the workspace
         * @param {string} storeName The name of the datastore
         * @param {FeatureTypeInfo} featureType The body of the feature type to POST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFeatureTypes(workspaceName: string, storeName: string, featureType: FeatureTypeInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postFeatureTypes(workspaceName, storeName, featureType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new feature type, the feature type definition needs to reference a store. Note -  when creating a new feature type via POST, if no underlying dataset with the specified name exists an attempt will be made to create it. This will work only in cases where the underlying data format supports the creation of new types (such as a database). When creating a feature type in this manner the client should include all attribute information in the feature type representation. 
         * @param {string} workspaceName The name of the workspace
         * @param {FeatureTypeInfo} featureType The body of the feature type to POST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFeatureTypes_6(workspaceName: string, featureType: FeatureTypeInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postFeatureTypes_6(workspaceName, featureType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update an individual feature type
         * @param {string} workspaceName The name of the workspace
         * @param {string} storeName The name of the datastore
         * @param {string} featureTypeName The name of the feature type
         * @param {FeatureTypeInfo} featureType The body of the feature type to POST
         * @param {Array<'nativebbox' | 'latlonbbox'>} [recalculate] Specifies whether to recalculate any bounding boxes for a feature type. Some properties of feature types are automatically recalculated when necessary. In particular, the native bounding box is recalculated when the projection or projection policy are changed, and the lat/lon bounding box is recalculated when the native bounding box is recalculated, or when a new native bounding box is explicitly provided in the request. (The native and lat/lon bounding boxes are not automatically recalculated when they are explicitly included in the request.) In addition, the client may explicitly request a fixed set of fields to calculate, by including a comma-separated list of their names in the recalculate parameter.  The empty parameter \&#39;recalculate&#x3D;\&#39; is useful avoid slow recalculation when operating against large datasets as \&#39;recalculate&#x3D;\&#39; avoids calculating any fields, regardless of any changes to projection, projection policy, etc. The nativebbox parameter \&#39;recalculate&#x3D;nativebbox\&#39; is used recalculates the native bounding box, while avoiding recalculating the lat/lon bounding box. Recalculate parameters can be used in together - \&#39;recalculate&#x3D;nativebbox,latlonbbox\&#39; can be used after a bulk import to recalculate both the native bounding box and the lat/lon bounding box.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFeatureType(workspaceName: string, storeName: string, featureTypeName: string, featureType: FeatureTypeInfo, recalculate?: Array<'nativebbox' | 'latlonbbox'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).putFeatureType(workspaceName, storeName, featureTypeName, featureType, recalculate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update an individual feature type in the default data store for the workspace
         * @param {string} workspaceName The name of the workspace
         * @param {string} featureTypeName The name of the feature type
         * @param {FeatureTypeInfo} featureType The body of the feature type to POST
         * @param {Array<'nativebbox' | 'latlonbbox'>} [recalculate] Specifies whether to recalculate any bounding boxes for a feature type. Some properties of feature types are automatically recalculated when necessary. In particular, the native bounding box is recalculated when the projection or projection policy are changed, and the lat/lon bounding box is recalculated when the native bounding box is recalculated, or when a new native bounding box is explicitly provided in the request. (The native and lat/lon bounding boxes are not automatically recalculated when they are explicitly included in the request.) In addition, the client may explicitly request a fixed set of fields to calculate, by including a comma-separated list of their names in the recalculate parameter.  The empty parameter \&#39;recalculate&#x3D;\&#39; is useful avoid slow recalculation when operating against large datasets as \&#39;recalculate&#x3D;\&#39; avoids calculating any fields, regardless of any changes to projection, projection policy, etc. The nativebbox parameter \&#39;recalculate&#x3D;nativebbox\&#39; is used recalculates the native bounding box, while avoiding recalculating the lat/lon bounding box. Recalculate parameters can be used in together - \&#39;recalculate&#x3D;nativebbox,latlonbbox\&#39; can be used after a bulk import to recalculate both the native bounding box and the lat/lon bounding box.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFeatureType_7(workspaceName: string, featureTypeName: string, featureType: FeatureTypeInfo, recalculate?: Array<'nativebbox' | 'latlonbbox'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).putFeatureType_7(workspaceName, featureTypeName, featureType, recalculate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Invalid. Use POST for adding a new feature type, or PUT on an individual feature type to edit that type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFeatureTypes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).putFeatureTypes(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Invalid. Use POST for adding a new feature type, or PUT on an individual feature type to edit that type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFeatureTypes_8(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).putFeatureTypes_8(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete a feature type (optionally recursively deleting layers).
         * @param {string} workspaceName The name of the workspace
         * @param {string} storeName The name of the datastore
         * @param {string} featureTypeName The name of the feature type
         * @param {boolean} [recurse] Recursively deletes all layers referenced by the specified featuretype. Allowed values for this parameter are true or false. The default value is false. A request with \&#39;recurse&#x3D;false\&#39; will fail if any layers reference the featuretype.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeatureType(workspaceName: string, storeName: string, featureTypeName: string, recurse?: boolean, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).deleteFeatureType(workspaceName, storeName, featureTypeName, recurse, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a feature type in the default data store for the workspace (optionally recursively deleting layers).
         * @param {string} workspaceName The name of the workspace
         * @param {string} featureTypeName The name of the feature type
         * @param {boolean} [recurse] Recursively deletes all layers referenced by the specified featuretype. Allowed values for this parameter are true or false. The default value is false. A request with \&#39;recurse&#x3D;false\&#39; will fail if any layers reference the featuretype.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeatureType_1(workspaceName: string, featureTypeName: string, recurse?: boolean, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).deleteFeatureType_1(workspaceName, featureTypeName, recurse, options).then((request) => request(axios, basePath));
        },
        /**
         * Invalid.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeatureTypes(options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).deleteFeatureTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * Invalid.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeatureTypes_2(options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).deleteFeatureTypes_2(options).then((request) => request(axios, basePath));
        },
        /**
         * Get an individual feature type
         * @param {string} workspaceName The name of the workspace
         * @param {string} storeName The name of the datastore
         * @param {string} featureTypeName The name of the feature type
         * @param {boolean} [quietOnNotFound] Prevents logging an Exception when the feature type is not present. Note that 404 status code will be returned anyway. Defaults to \&quot;false\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureType(workspaceName: string, storeName: string, featureTypeName: string, quietOnNotFound?: boolean, options?: any): AxiosPromise<InlineResponse2001> {
            return DefaultApiFp(configuration).getFeatureType(workspaceName, storeName, featureTypeName, quietOnNotFound, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an individual feature type in the default data store for the workspace
         * @param {string} workspaceName The name of the workspace
         * @param {string} featureTypeName The name of the feature type
         * @param {boolean} [quietOnNotFound] Prevents logging an Exception when the feature type is not present. Note that 404 status code will be returned anyway. Defaults to \&quot;false\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureType_3(workspaceName: string, featureTypeName: string, quietOnNotFound?: boolean, options?: any): AxiosPromise<InlineResponse2001> {
            return DefaultApiFp(configuration).getFeatureType_3(workspaceName, featureTypeName, quietOnNotFound, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of feature types for the workspace and datastore. Use the \"Accept:\" header to specify format or append an extension to the endpoint (example \"/featuretypes.xml\" for XML) 
         * @param {string} workspaceName The name of the workspace
         * @param {string} storeName The name of the datastore
         * @param {'configured' | 'available' | 'available_with_geom' | 'all'} [list] The list parameter is used to control the category of feature types that are returned. Must be one of \&quot;configured\&quot;, \&quot;available\&quot;, \&quot;available_with_geom\&quot;, \&quot;all\&quot; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureTypes(workspaceName: string, storeName: string, list?: 'configured' | 'available' | 'available_with_geom' | 'all', options?: any): AxiosPromise<InlineResponse200> {
            return DefaultApiFp(configuration).getFeatureTypes(workspaceName, storeName, list, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all feature types for all datastores in the workspace. Use the \"Accept:\" header to specify format or append an extension to the endpoint (example \"/featuretypes.xml\" for XML) 
         * @param {string} workspaceName The name of the workspace
         * @param {'configured' | 'available' | 'available_with_geom' | 'all'} [list] The list parameter is used to control the category of feature types that are returned. Must be one of \&quot;configured\&quot;, \&quot;available\&quot;, \&quot;available_with_geom\&quot;, \&quot;all\&quot; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureTypes_4(workspaceName: string, list?: 'configured' | 'available' | 'available_with_geom' | 'all', options?: any): AxiosPromise<InlineResponse200> {
            return DefaultApiFp(configuration).getFeatureTypes_4(workspaceName, list, options).then((request) => request(axios, basePath));
        },
        /**
         * Invalid. Use POST on the /featuretypes endpoint to add a new feature type, or PUT on an individual feature type to edit that type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFeatureType(options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).postFeatureType(options).then((request) => request(axios, basePath));
        },
        /**
         * Invalid. Use POST on the /featuretypes endpoint to add a new feature type, or PUT on an individual feature type to edit that type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFeatureType_5(options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).postFeatureType_5(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new feature type. Note -  when creating a new feature type via POST, if no underlying dataset with the specified name exists an attempt will be made to create it. This will work only in cases where the underlying data format supports the creation of new types (such as a database). When creating a feature type in this manner the client should include all attribute information in the feature type representation. 
         * @param {string} workspaceName The name of the workspace
         * @param {string} storeName The name of the datastore
         * @param {FeatureTypeInfo} featureType The body of the feature type to POST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFeatureTypes(workspaceName: string, storeName: string, featureType: FeatureTypeInfo, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).postFeatureTypes(workspaceName, storeName, featureType, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new feature type, the feature type definition needs to reference a store. Note -  when creating a new feature type via POST, if no underlying dataset with the specified name exists an attempt will be made to create it. This will work only in cases where the underlying data format supports the creation of new types (such as a database). When creating a feature type in this manner the client should include all attribute information in the feature type representation. 
         * @param {string} workspaceName The name of the workspace
         * @param {FeatureTypeInfo} featureType The body of the feature type to POST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFeatureTypes_6(workspaceName: string, featureType: FeatureTypeInfo, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).postFeatureTypes_6(workspaceName, featureType, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an individual feature type
         * @param {string} workspaceName The name of the workspace
         * @param {string} storeName The name of the datastore
         * @param {string} featureTypeName The name of the feature type
         * @param {FeatureTypeInfo} featureType The body of the feature type to POST
         * @param {Array<'nativebbox' | 'latlonbbox'>} [recalculate] Specifies whether to recalculate any bounding boxes for a feature type. Some properties of feature types are automatically recalculated when necessary. In particular, the native bounding box is recalculated when the projection or projection policy are changed, and the lat/lon bounding box is recalculated when the native bounding box is recalculated, or when a new native bounding box is explicitly provided in the request. (The native and lat/lon bounding boxes are not automatically recalculated when they are explicitly included in the request.) In addition, the client may explicitly request a fixed set of fields to calculate, by including a comma-separated list of their names in the recalculate parameter.  The empty parameter \&#39;recalculate&#x3D;\&#39; is useful avoid slow recalculation when operating against large datasets as \&#39;recalculate&#x3D;\&#39; avoids calculating any fields, regardless of any changes to projection, projection policy, etc. The nativebbox parameter \&#39;recalculate&#x3D;nativebbox\&#39; is used recalculates the native bounding box, while avoiding recalculating the lat/lon bounding box. Recalculate parameters can be used in together - \&#39;recalculate&#x3D;nativebbox,latlonbbox\&#39; can be used after a bulk import to recalculate both the native bounding box and the lat/lon bounding box.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFeatureType(workspaceName: string, storeName: string, featureTypeName: string, featureType: FeatureTypeInfo, recalculate?: Array<'nativebbox' | 'latlonbbox'>, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).putFeatureType(workspaceName, storeName, featureTypeName, featureType, recalculate, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an individual feature type in the default data store for the workspace
         * @param {string} workspaceName The name of the workspace
         * @param {string} featureTypeName The name of the feature type
         * @param {FeatureTypeInfo} featureType The body of the feature type to POST
         * @param {Array<'nativebbox' | 'latlonbbox'>} [recalculate] Specifies whether to recalculate any bounding boxes for a feature type. Some properties of feature types are automatically recalculated when necessary. In particular, the native bounding box is recalculated when the projection or projection policy are changed, and the lat/lon bounding box is recalculated when the native bounding box is recalculated, or when a new native bounding box is explicitly provided in the request. (The native and lat/lon bounding boxes are not automatically recalculated when they are explicitly included in the request.) In addition, the client may explicitly request a fixed set of fields to calculate, by including a comma-separated list of their names in the recalculate parameter.  The empty parameter \&#39;recalculate&#x3D;\&#39; is useful avoid slow recalculation when operating against large datasets as \&#39;recalculate&#x3D;\&#39; avoids calculating any fields, regardless of any changes to projection, projection policy, etc. The nativebbox parameter \&#39;recalculate&#x3D;nativebbox\&#39; is used recalculates the native bounding box, while avoiding recalculating the lat/lon bounding box. Recalculate parameters can be used in together - \&#39;recalculate&#x3D;nativebbox,latlonbbox\&#39; can be used after a bulk import to recalculate both the native bounding box and the lat/lon bounding box.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFeatureType_7(workspaceName: string, featureTypeName: string, featureType: FeatureTypeInfo, recalculate?: Array<'nativebbox' | 'latlonbbox'>, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).putFeatureType_7(workspaceName, featureTypeName, featureType, recalculate, options).then((request) => request(axios, basePath));
        },
        /**
         * Invalid. Use POST for adding a new feature type, or PUT on an individual feature type to edit that type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFeatureTypes(options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).putFeatureTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * Invalid. Use POST for adding a new feature type, or PUT on an individual feature type to edit that type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFeatureTypes_8(options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).putFeatureTypes_8(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
    /**
     * Delete a feature type (optionally recursively deleting layers).
     * @param {string} workspaceName The name of the workspace
     * @param {string} storeName The name of the datastore
     * @param {string} featureTypeName The name of the feature type
     * @param {boolean} [recurse] Recursively deletes all layers referenced by the specified featuretype. Allowed values for this parameter are true or false. The default value is false. A request with \&#39;recurse&#x3D;false\&#39; will fail if any layers reference the featuretype.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    deleteFeatureType(workspaceName: string, storeName: string, featureTypeName: string, recurse?: boolean, options?: any): AxiosPromise<void>;

    /**
     * Delete a feature type in the default data store for the workspace (optionally recursively deleting layers).
     * @param {string} workspaceName The name of the workspace
     * @param {string} featureTypeName The name of the feature type
     * @param {boolean} [recurse] Recursively deletes all layers referenced by the specified featuretype. Allowed values for this parameter are true or false. The default value is false. A request with \&#39;recurse&#x3D;false\&#39; will fail if any layers reference the featuretype.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    deleteFeatureType_1(workspaceName: string, featureTypeName: string, recurse?: boolean, options?: any): AxiosPromise<void>;

    /**
     * Invalid.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    deleteFeatureTypes(options?: any): AxiosPromise<void>;

    /**
     * Invalid.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    deleteFeatureTypes_2(options?: any): AxiosPromise<void>;

    /**
     * Get an individual feature type
     * @param {string} workspaceName The name of the workspace
     * @param {string} storeName The name of the datastore
     * @param {string} featureTypeName The name of the feature type
     * @param {boolean} [quietOnNotFound] Prevents logging an Exception when the feature type is not present. Note that 404 status code will be returned anyway. Defaults to \&quot;false\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getFeatureType(workspaceName: string, storeName: string, featureTypeName: string, quietOnNotFound?: boolean, options?: any): AxiosPromise<InlineResponse2001>;

    /**
     * Get an individual feature type in the default data store for the workspace
     * @param {string} workspaceName The name of the workspace
     * @param {string} featureTypeName The name of the feature type
     * @param {boolean} [quietOnNotFound] Prevents logging an Exception when the feature type is not present. Note that 404 status code will be returned anyway. Defaults to \&quot;false\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getFeatureType_3(workspaceName: string, featureTypeName: string, quietOnNotFound?: boolean, options?: any): AxiosPromise<InlineResponse2001>;

    /**
     * Get a list of feature types for the workspace and datastore. Use the \"Accept:\" header to specify format or append an extension to the endpoint (example \"/featuretypes.xml\" for XML) 
     * @param {string} workspaceName The name of the workspace
     * @param {string} storeName The name of the datastore
     * @param {'configured' | 'available' | 'available_with_geom' | 'all'} [list] The list parameter is used to control the category of feature types that are returned. Must be one of \&quot;configured\&quot;, \&quot;available\&quot;, \&quot;available_with_geom\&quot;, \&quot;all\&quot; 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getFeatureTypes(workspaceName: string, storeName: string, list?: 'configured' | 'available' | 'available_with_geom' | 'all', options?: any): AxiosPromise<InlineResponse200>;

    /**
     * Get a list of all feature types for all datastores in the workspace. Use the \"Accept:\" header to specify format or append an extension to the endpoint (example \"/featuretypes.xml\" for XML) 
     * @param {string} workspaceName The name of the workspace
     * @param {'configured' | 'available' | 'available_with_geom' | 'all'} [list] The list parameter is used to control the category of feature types that are returned. Must be one of \&quot;configured\&quot;, \&quot;available\&quot;, \&quot;available_with_geom\&quot;, \&quot;all\&quot; 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getFeatureTypes_4(workspaceName: string, list?: 'configured' | 'available' | 'available_with_geom' | 'all', options?: any): AxiosPromise<InlineResponse200>;

    /**
     * Invalid. Use POST on the /featuretypes endpoint to add a new feature type, or PUT on an individual feature type to edit that type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postFeatureType(options?: any): AxiosPromise<void>;

    /**
     * Invalid. Use POST on the /featuretypes endpoint to add a new feature type, or PUT on an individual feature type to edit that type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postFeatureType_5(options?: any): AxiosPromise<void>;

    /**
     * Create a new feature type. Note -  when creating a new feature type via POST, if no underlying dataset with the specified name exists an attempt will be made to create it. This will work only in cases where the underlying data format supports the creation of new types (such as a database). When creating a feature type in this manner the client should include all attribute information in the feature type representation. 
     * @param {string} workspaceName The name of the workspace
     * @param {string} storeName The name of the datastore
     * @param {FeatureTypeInfo} featureType The body of the feature type to POST
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postFeatureTypes(workspaceName: string, storeName: string, featureType: FeatureTypeInfo, options?: any): AxiosPromise<void>;

    /**
     * Create a new feature type, the feature type definition needs to reference a store. Note -  when creating a new feature type via POST, if no underlying dataset with the specified name exists an attempt will be made to create it. This will work only in cases where the underlying data format supports the creation of new types (such as a database). When creating a feature type in this manner the client should include all attribute information in the feature type representation. 
     * @param {string} workspaceName The name of the workspace
     * @param {FeatureTypeInfo} featureType The body of the feature type to POST
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postFeatureTypes_6(workspaceName: string, featureType: FeatureTypeInfo, options?: any): AxiosPromise<void>;

    /**
     * Update an individual feature type
     * @param {string} workspaceName The name of the workspace
     * @param {string} storeName The name of the datastore
     * @param {string} featureTypeName The name of the feature type
     * @param {FeatureTypeInfo} featureType The body of the feature type to POST
     * @param {Array<'nativebbox' | 'latlonbbox'>} [recalculate] Specifies whether to recalculate any bounding boxes for a feature type. Some properties of feature types are automatically recalculated when necessary. In particular, the native bounding box is recalculated when the projection or projection policy are changed, and the lat/lon bounding box is recalculated when the native bounding box is recalculated, or when a new native bounding box is explicitly provided in the request. (The native and lat/lon bounding boxes are not automatically recalculated when they are explicitly included in the request.) In addition, the client may explicitly request a fixed set of fields to calculate, by including a comma-separated list of their names in the recalculate parameter.  The empty parameter \&#39;recalculate&#x3D;\&#39; is useful avoid slow recalculation when operating against large datasets as \&#39;recalculate&#x3D;\&#39; avoids calculating any fields, regardless of any changes to projection, projection policy, etc. The nativebbox parameter \&#39;recalculate&#x3D;nativebbox\&#39; is used recalculates the native bounding box, while avoiding recalculating the lat/lon bounding box. Recalculate parameters can be used in together - \&#39;recalculate&#x3D;nativebbox,latlonbbox\&#39; can be used after a bulk import to recalculate both the native bounding box and the lat/lon bounding box.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    putFeatureType(workspaceName: string, storeName: string, featureTypeName: string, featureType: FeatureTypeInfo, recalculate?: Array<'nativebbox' | 'latlonbbox'>, options?: any): AxiosPromise<void>;

    /**
     * Update an individual feature type in the default data store for the workspace
     * @param {string} workspaceName The name of the workspace
     * @param {string} featureTypeName The name of the feature type
     * @param {FeatureTypeInfo} featureType The body of the feature type to POST
     * @param {Array<'nativebbox' | 'latlonbbox'>} [recalculate] Specifies whether to recalculate any bounding boxes for a feature type. Some properties of feature types are automatically recalculated when necessary. In particular, the native bounding box is recalculated when the projection or projection policy are changed, and the lat/lon bounding box is recalculated when the native bounding box is recalculated, or when a new native bounding box is explicitly provided in the request. (The native and lat/lon bounding boxes are not automatically recalculated when they are explicitly included in the request.) In addition, the client may explicitly request a fixed set of fields to calculate, by including a comma-separated list of their names in the recalculate parameter.  The empty parameter \&#39;recalculate&#x3D;\&#39; is useful avoid slow recalculation when operating against large datasets as \&#39;recalculate&#x3D;\&#39; avoids calculating any fields, regardless of any changes to projection, projection policy, etc. The nativebbox parameter \&#39;recalculate&#x3D;nativebbox\&#39; is used recalculates the native bounding box, while avoiding recalculating the lat/lon bounding box. Recalculate parameters can be used in together - \&#39;recalculate&#x3D;nativebbox,latlonbbox\&#39; can be used after a bulk import to recalculate both the native bounding box and the lat/lon bounding box.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    putFeatureType_7(workspaceName: string, featureTypeName: string, featureType: FeatureTypeInfo, recalculate?: Array<'nativebbox' | 'latlonbbox'>, options?: any): AxiosPromise<void>;

    /**
     * Invalid. Use POST for adding a new feature type, or PUT on an individual feature type to edit that type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    putFeatureTypes(options?: any): AxiosPromise<void>;

    /**
     * Invalid. Use POST for adding a new feature type, or PUT on an individual feature type to edit that type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    putFeatureTypes_8(options?: any): AxiosPromise<void>;

}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
    /**
     * Delete a feature type (optionally recursively deleting layers).
     * @param {string} workspaceName The name of the workspace
     * @param {string} storeName The name of the datastore
     * @param {string} featureTypeName The name of the feature type
     * @param {boolean} [recurse] Recursively deletes all layers referenced by the specified featuretype. Allowed values for this parameter are true or false. The default value is false. A request with \&#39;recurse&#x3D;false\&#39; will fail if any layers reference the featuretype.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteFeatureType(workspaceName: string, storeName: string, featureTypeName: string, recurse?: boolean, options?: any) {
        return DefaultApiFp(this.configuration).deleteFeatureType(workspaceName, storeName, featureTypeName, recurse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a feature type in the default data store for the workspace (optionally recursively deleting layers).
     * @param {string} workspaceName The name of the workspace
     * @param {string} featureTypeName The name of the feature type
     * @param {boolean} [recurse] Recursively deletes all layers referenced by the specified featuretype. Allowed values for this parameter are true or false. The default value is false. A request with \&#39;recurse&#x3D;false\&#39; will fail if any layers reference the featuretype.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteFeatureType_1(workspaceName: string, featureTypeName: string, recurse?: boolean, options?: any) {
        return DefaultApiFp(this.configuration).deleteFeatureType_1(workspaceName, featureTypeName, recurse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invalid.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteFeatureTypes(options?: any) {
        return DefaultApiFp(this.configuration).deleteFeatureTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invalid.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteFeatureTypes_2(options?: any) {
        return DefaultApiFp(this.configuration).deleteFeatureTypes_2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an individual feature type
     * @param {string} workspaceName The name of the workspace
     * @param {string} storeName The name of the datastore
     * @param {string} featureTypeName The name of the feature type
     * @param {boolean} [quietOnNotFound] Prevents logging an Exception when the feature type is not present. Note that 404 status code will be returned anyway. Defaults to \&quot;false\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFeatureType(workspaceName: string, storeName: string, featureTypeName: string, quietOnNotFound?: boolean, options?: any) {
        return DefaultApiFp(this.configuration).getFeatureType(workspaceName, storeName, featureTypeName, quietOnNotFound, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an individual feature type in the default data store for the workspace
     * @param {string} workspaceName The name of the workspace
     * @param {string} featureTypeName The name of the feature type
     * @param {boolean} [quietOnNotFound] Prevents logging an Exception when the feature type is not present. Note that 404 status code will be returned anyway. Defaults to \&quot;false\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFeatureType_3(workspaceName: string, featureTypeName: string, quietOnNotFound?: boolean, options?: any) {
        return DefaultApiFp(this.configuration).getFeatureType_3(workspaceName, featureTypeName, quietOnNotFound, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of feature types for the workspace and datastore. Use the \"Accept:\" header to specify format or append an extension to the endpoint (example \"/featuretypes.xml\" for XML) 
     * @param {string} workspaceName The name of the workspace
     * @param {string} storeName The name of the datastore
     * @param {'configured' | 'available' | 'available_with_geom' | 'all'} [list] The list parameter is used to control the category of feature types that are returned. Must be one of \&quot;configured\&quot;, \&quot;available\&quot;, \&quot;available_with_geom\&quot;, \&quot;all\&quot; 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFeatureTypes(workspaceName: string, storeName: string, list?: 'configured' | 'available' | 'available_with_geom' | 'all', options?: any) {
        return DefaultApiFp(this.configuration).getFeatureTypes(workspaceName, storeName, list, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all feature types for all datastores in the workspace. Use the \"Accept:\" header to specify format or append an extension to the endpoint (example \"/featuretypes.xml\" for XML) 
     * @param {string} workspaceName The name of the workspace
     * @param {'configured' | 'available' | 'available_with_geom' | 'all'} [list] The list parameter is used to control the category of feature types that are returned. Must be one of \&quot;configured\&quot;, \&quot;available\&quot;, \&quot;available_with_geom\&quot;, \&quot;all\&quot; 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFeatureTypes_4(workspaceName: string, list?: 'configured' | 'available' | 'available_with_geom' | 'all', options?: any) {
        return DefaultApiFp(this.configuration).getFeatureTypes_4(workspaceName, list, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invalid. Use POST on the /featuretypes endpoint to add a new feature type, or PUT on an individual feature type to edit that type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postFeatureType(options?: any) {
        return DefaultApiFp(this.configuration).postFeatureType(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invalid. Use POST on the /featuretypes endpoint to add a new feature type, or PUT on an individual feature type to edit that type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postFeatureType_5(options?: any) {
        return DefaultApiFp(this.configuration).postFeatureType_5(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new feature type. Note -  when creating a new feature type via POST, if no underlying dataset with the specified name exists an attempt will be made to create it. This will work only in cases where the underlying data format supports the creation of new types (such as a database). When creating a feature type in this manner the client should include all attribute information in the feature type representation. 
     * @param {string} workspaceName The name of the workspace
     * @param {string} storeName The name of the datastore
     * @param {FeatureTypeInfo} featureType The body of the feature type to POST
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postFeatureTypes(workspaceName: string, storeName: string, featureType: FeatureTypeInfo, options?: any) {
        return DefaultApiFp(this.configuration).postFeatureTypes(workspaceName, storeName, featureType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new feature type, the feature type definition needs to reference a store. Note -  when creating a new feature type via POST, if no underlying dataset with the specified name exists an attempt will be made to create it. This will work only in cases where the underlying data format supports the creation of new types (such as a database). When creating a feature type in this manner the client should include all attribute information in the feature type representation. 
     * @param {string} workspaceName The name of the workspace
     * @param {FeatureTypeInfo} featureType The body of the feature type to POST
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postFeatureTypes_6(workspaceName: string, featureType: FeatureTypeInfo, options?: any) {
        return DefaultApiFp(this.configuration).postFeatureTypes_6(workspaceName, featureType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an individual feature type
     * @param {string} workspaceName The name of the workspace
     * @param {string} storeName The name of the datastore
     * @param {string} featureTypeName The name of the feature type
     * @param {FeatureTypeInfo} featureType The body of the feature type to POST
     * @param {Array<'nativebbox' | 'latlonbbox'>} [recalculate] Specifies whether to recalculate any bounding boxes for a feature type. Some properties of feature types are automatically recalculated when necessary. In particular, the native bounding box is recalculated when the projection or projection policy are changed, and the lat/lon bounding box is recalculated when the native bounding box is recalculated, or when a new native bounding box is explicitly provided in the request. (The native and lat/lon bounding boxes are not automatically recalculated when they are explicitly included in the request.) In addition, the client may explicitly request a fixed set of fields to calculate, by including a comma-separated list of their names in the recalculate parameter.  The empty parameter \&#39;recalculate&#x3D;\&#39; is useful avoid slow recalculation when operating against large datasets as \&#39;recalculate&#x3D;\&#39; avoids calculating any fields, regardless of any changes to projection, projection policy, etc. The nativebbox parameter \&#39;recalculate&#x3D;nativebbox\&#39; is used recalculates the native bounding box, while avoiding recalculating the lat/lon bounding box. Recalculate parameters can be used in together - \&#39;recalculate&#x3D;nativebbox,latlonbbox\&#39; can be used after a bulk import to recalculate both the native bounding box and the lat/lon bounding box.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putFeatureType(workspaceName: string, storeName: string, featureTypeName: string, featureType: FeatureTypeInfo, recalculate?: Array<'nativebbox' | 'latlonbbox'>, options?: any) {
        return DefaultApiFp(this.configuration).putFeatureType(workspaceName, storeName, featureTypeName, featureType, recalculate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an individual feature type in the default data store for the workspace
     * @param {string} workspaceName The name of the workspace
     * @param {string} featureTypeName The name of the feature type
     * @param {FeatureTypeInfo} featureType The body of the feature type to POST
     * @param {Array<'nativebbox' | 'latlonbbox'>} [recalculate] Specifies whether to recalculate any bounding boxes for a feature type. Some properties of feature types are automatically recalculated when necessary. In particular, the native bounding box is recalculated when the projection or projection policy are changed, and the lat/lon bounding box is recalculated when the native bounding box is recalculated, or when a new native bounding box is explicitly provided in the request. (The native and lat/lon bounding boxes are not automatically recalculated when they are explicitly included in the request.) In addition, the client may explicitly request a fixed set of fields to calculate, by including a comma-separated list of their names in the recalculate parameter.  The empty parameter \&#39;recalculate&#x3D;\&#39; is useful avoid slow recalculation when operating against large datasets as \&#39;recalculate&#x3D;\&#39; avoids calculating any fields, regardless of any changes to projection, projection policy, etc. The nativebbox parameter \&#39;recalculate&#x3D;nativebbox\&#39; is used recalculates the native bounding box, while avoiding recalculating the lat/lon bounding box. Recalculate parameters can be used in together - \&#39;recalculate&#x3D;nativebbox,latlonbbox\&#39; can be used after a bulk import to recalculate both the native bounding box and the lat/lon bounding box.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putFeatureType_7(workspaceName: string, featureTypeName: string, featureType: FeatureTypeInfo, recalculate?: Array<'nativebbox' | 'latlonbbox'>, options?: any) {
        return DefaultApiFp(this.configuration).putFeatureType_7(workspaceName, featureTypeName, featureType, recalculate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invalid. Use POST for adding a new feature type, or PUT on an individual feature type to edit that type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putFeatureTypes(options?: any) {
        return DefaultApiFp(this.configuration).putFeatureTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invalid. Use POST for adding a new feature type, or PUT on an individual feature type to edit that type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putFeatureTypes_8(options?: any) {
        return DefaultApiFp(this.configuration).putFeatureTypes_8(options).then((request) => request(this.axios, this.basePath));
    }

}


