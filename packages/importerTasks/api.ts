// tslint:disable
/**
 * GeoServer Importer Extension - Tasks
 * The Importer extension gives a GeoServer administrator an alternate, more-streamlined method for uploading and configuring new layers. The tasks endpoint controls individual tasks within an import job. The importer extension is an optional install and may not be available on all deployments of GeoServer
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: geoserver-users@sourceforge.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * A spatially referenced bounding box.
 * @export
 * @interface Bbox
 */
export interface Bbox {
    /**
     * The minimum x value
     * @type {string}
     * @memberof Bbox
     */
    minx?: string;
    /**
     * The minimum y value
     * @type {string}
     * @memberof Bbox
     */
    miny?: string;
    /**
     * The maximum x value
     * @type {string}
     * @memberof Bbox
     */
    maxx?: string;
    /**
     * The maximum y value
     * @type {string}
     * @memberof Bbox
     */
    maxy?: string;
    /**
     * The WKT representation of the CRS.
     * @type {string}
     * @memberof Bbox
     */
    crs?: string;
}
/**
 * A data representation. Paramaters vary depending on the type.
 * @export
 * @interface Data
 */
export interface Data {
    /**
     * The type of the data
     * @type {string}
     * @memberof Data
     */
    type?: DataTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum DataTypeEnum {
    Remote = 'remote',
    File = 'file',
    Directory = 'directory',
    Mosaic = 'mosaic',
    Database = 'database',
    Table = 'table'
}

/**
 * A layer
 * @export
 * @interface Layer
 */
export interface Layer {
    /**
     * The name of the layer
     * @type {string}
     * @memberof Layer
     */
    name?: string;
    /**
     * URL to the importer layer endpoint
     * @type {string}
     * @memberof Layer
     */
    href?: string;
    /**
     * The layer title
     * @type {string}
     * @memberof Layer
     */
    title?: string;
    /**
     * The layer abstract
     * @type {string}
     * @memberof Layer
     */
    _abstract?: string;
    /**
     * The layer description
     * @type {string}
     * @memberof Layer
     */
    description?: string;
    /**
     * The original name of the layer. This may be different from the name if this name already exists in geoserver.
     * @type {string}
     * @memberof Layer
     */
    originalName?: string;
    /**
     * The name of the underlying resource
     * @type {string}
     * @memberof Layer
     */
    nativeName?: string;
    /**
     * The SRS of the layer
     * @type {string}
     * @memberof Layer
     */
    srs?: string;
    /**
     * 
     * @type {Bbox}
     * @memberof Layer
     */
    bbox?: Bbox;
    /**
     * Feature type attributes
     * @type {Array<object>}
     * @memberof Layer
     */
    attributes?: Array<object>;
    /**
     * 
     * @type {Style}
     * @memberof Layer
     */
    style?: Style;
}
/**
 * Task progress
 * @export
 * @interface Progress
 */
export interface Progress {
    /**
     * Number of operations completed
     * @type {string}
     * @memberof Progress
     */
    progress?: string;
    /**
     * Total number of operations
     * @type {string}
     * @memberof Progress
     */
    total?: string;
    /**
     * State of the task.
     * @type {string}
     * @memberof Progress
     */
    state?: ProgressStateEnum;
    /**
     * Error message. Only shown if state is \"ERROR\"
     * @type {string}
     * @memberof Progress
     */
    message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ProgressStateEnum {
    PENDING = 'PENDING',
    READY = 'READY',
    RUNNING = 'RUNNING',
    NOCRS = 'NO_CRS',
    NOBOUNDS = 'NO_BOUNDS',
    NOFORMAT = 'NO_FORMAT',
    BADFORMAT = 'BAD_FORMAT',
    ERROR = 'ERROR',
    CANCELED = 'CANCELED',
    COMPLETE = 'COMPLETE'
}

/**
 * A store
 * @export
 * @interface Store
 */
export interface Store {
    /**
     * URL to the task target endpoint
     * @type {string}
     * @memberof Store
     */
    href?: string;
    /**
     * JSON representation of the store
     * @type {object}
     * @memberof Store
     */
    store?: object;
}
/**
 * A layer style
 * @export
 * @interface Style
 */
export interface Style {
    /**
     * Name of the style
     * @type {string}
     * @memberof Style
     */
    name?: string;
    /**
     * URL to the importer layer style endpoint
     * @type {string}
     * @memberof Style
     */
    href?: string;
    /**
     * Format of style
     * @type {string}
     * @memberof Style
     */
    format?: string;
    /**
     * 
     * @type {StyleLanguageVersion}
     * @memberof Style
     */
    languageVersion?: StyleLanguageVersion;
    /**
     * File name of the style
     * @type {string}
     * @memberof Style
     */
    filename?: string;
}
/**
 * 
 * @export
 * @interface StyleLanguageVersion
 */
export interface StyleLanguageVersion {
    /**
     * Version of style format
     * @type {string}
     * @memberof StyleLanguageVersion
     */
    version?: string;
}
/**
 * An import task
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * The task id
     * @type {string}
     * @memberof Task
     */
    id?: string;
    /**
     * URL to the task endpoint
     * @type {string}
     * @memberof Task
     */
    href?: string;
    /**
     * State of the task.
     * @type {string}
     * @memberof Task
     */
    state?: TaskStateEnum;
    /**
     * Update mode of the task.
     * @type {string}
     * @memberof Task
     */
    updateMode?: TaskUpdateModeEnum;
    /**
     * 
     * @type {Data}
     * @memberof Task
     */
    data?: Data;
    /**
     * 
     * @type {Store}
     * @memberof Task
     */
    target?: Store;
    /**
     * URL to the progress endpoint for this task
     * @type {string}
     * @memberof Task
     */
    progress?: string;
    /**
     * 
     * @type {Layer}
     * @memberof Task
     */
    layer?: Layer;
    /**
     * Any error messages for the task, concatenated.
     * @type {string}
     * @memberof Task
     */
    errorMessage?: string;
    /**
     * 
     * @type {TransformChain}
     * @memberof Task
     */
    transformChain?: TransformChain;
    /**
     * A list of log messages
     * @type {Array<object>}
     * @memberof Task
     */
    messages?: Array<object>;
}

/**
    * @export
    * @enum {string}
    */
export enum TaskStateEnum {
    PENDING = 'PENDING',
    READY = 'READY',
    RUNNING = 'RUNNING',
    NOCRS = 'NO_CRS',
    NOBOUNDS = 'NO_BOUNDS',
    NOFORMAT = 'NO_FORMAT',
    BADFORMAT = 'BAD_FORMAT',
    ERROR = 'ERROR',
    CANCELED = 'CANCELED',
    COMPLETE = 'COMPLETE'
}
/**
    * @export
    * @enum {string}
    */
export enum TaskUpdateModeEnum {
    CREATE = 'CREATE',
    REPLACE = 'REPLACE',
    APPEND = 'APPEND',
    UPDATE = 'UPDATE'
}

/**
 * A data transform applied to the import data.
 * @export
 * @interface Transform
 */
export interface Transform {
    /**
     * The name of the transform
     * @type {string}
     * @memberof Transform
     */
    type?: string;
    /**
     * URL to the transform endpoint
     * @type {string}
     * @memberof Transform
     */
    href?: string;
}
/**
 * A chain of tranform operations to apply during the import process
 * @export
 * @interface TransformChain
 */
export interface TransformChain {
    /**
     * The type of transforms in the chain. One of \"vector\" or \"raster\"
     * @type {string}
     * @memberof TransformChain
     */
    type?: string;
    /**
     * A list of transforms
     * @type {Array<Transform>}
     * @memberof TransformChain
     */
    transforms?: Array<Transform>;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove task with id {taskId} within import with id {importId}
         * @param {string} importId The ID of the import
         * @param {string} taskId The ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask: async (importId: string, taskId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'importId' is not null or undefined
            if (importId === null || importId === undefined) {
                throw new RequiredError('importId','Required parameter importId was null or undefined when calling deleteTask.');
            }
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling deleteTask.');
            }
            const localVarPath = `/imports/{importId}/tasks/{taskId}`
                .replace(`{${"importId"}}`, encodeURIComponent(String(importId)))
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve task with id {taskId} within import with id {importId}
         * @param {string} importId The ID of the import
         * @param {string} taskId The ID of the task
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask: async (importId: string, taskId: string, expand?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'importId' is not null or undefined
            if (importId === null || importId === undefined) {
                throw new RequiredError('importId','Required parameter importId was null or undefined when calling getTask.');
            }
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling getTask.');
            }
            const localVarPath = `/imports/{importId}/tasks/{taskId}`
                .replace(`{${"importId"}}`, encodeURIComponent(String(importId)))
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the layer of a task with id {taskId} within import with id {importId}
         * @param {string} importId The ID of the import
         * @param {string} taskId The ID of the task
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskLayer: async (importId: string, taskId: string, expand?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'importId' is not null or undefined
            if (importId === null || importId === undefined) {
                throw new RequiredError('importId','Required parameter importId was null or undefined when calling getTaskLayer.');
            }
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling getTaskLayer.');
            }
            const localVarPath = `/imports/{importId}/tasks/{taskId}/layer`
                .replace(`{${"importId"}}`, encodeURIComponent(String(importId)))
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the current state and import progress of a task with id {taskId} within import with id {importId}
         * @param {string} importId The ID of the import
         * @param {string} taskId The ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskProgress: async (importId: string, taskId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'importId' is not null or undefined
            if (importId === null || importId === undefined) {
                throw new RequiredError('importId','Required parameter importId was null or undefined when calling getTaskProgress.');
            }
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling getTaskProgress.');
            }
            const localVarPath = `/imports/{importId}/tasks/{taskId}/progress`
                .replace(`{${"importId"}}`, encodeURIComponent(String(importId)))
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the store of a task with id {taskId} within import with id {importId}
         * @param {string} importId The ID of the import
         * @param {string} taskId The ID of the task
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskTarget: async (importId: string, taskId: string, expand?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'importId' is not null or undefined
            if (importId === null || importId === undefined) {
                throw new RequiredError('importId','Required parameter importId was null or undefined when calling getTaskTarget.');
            }
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling getTaskTarget.');
            }
            const localVarPath = `/imports/{importId}/tasks/{taskId}/target`
                .replace(`{${"importId"}}`, encodeURIComponent(String(importId)))
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve all tasks for import with id {importId}
         * @param {string} importId The ID of the import
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks: async (importId: string, expand?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'importId' is not null or undefined
            if (importId === null || importId === undefined) {
                throw new RequiredError('importId','Required parameter importId was null or undefined when calling getTasks.');
            }
            const localVarPath = `/imports/{importId}/tasks`
                .replace(`{${"importId"}}`, encodeURIComponent(String(importId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A new task can be created by issuing a POST to imports/<importId>/tasks as a \"Content-type: multipart/form-data\" multipart encoded data as defined by RFC 2388. One or more file can be uploaded this way, and a task will be created for importing them. In case the file being uploaded is a zip file, it will be unzipped on the server side and treated as a directory of files. Alternatively, a new task can be created by issuing a POST as a \"Content-type: application/x-www-form-urlencoded\" form url encoded data containing a url paramerter with the location of the uploaded file.
         * @summary Create a new task
         * @param {string} importId The ID of the import
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {string} [id] The task id
         * @param {string} [href] URL to the task endpoint
         * @param {string} [state] State of the task.
         * @param {string} [updateMode] Update mode of the task.
         * @param {Data} [data] 
         * @param {Store} [target] 
         * @param {string} [progress] URL to the progress endpoint for this task
         * @param {Layer} [layer] 
         * @param {string} [errorMessage] Any error messages for the task, concatenated.
         * @param {TransformChain} [transformChain] 
         * @param {Array<object>} [messages] A list of log messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTask: async (importId: string, expand?: string, id?: string, href?: string, state?: string, updateMode?: string, data?: Data, target?: Store, progress?: string, layer?: Layer, errorMessage?: string, transformChain?: TransformChain, messages?: Array<object>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'importId' is not null or undefined
            if (importId === null || importId === undefined) {
                throw new RequiredError('importId','Required parameter importId was null or undefined when calling postTask.');
            }
            const localVarPath = `/imports/{importId}/tasks`
                .replace(`{${"importId"}}`, encodeURIComponent(String(importId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


            if (id !== undefined) { 
                localVarFormParams.append('id', id as any);
            }
    
            if (href !== undefined) { 
                localVarFormParams.append('href', href as any);
            }
    
            if (state !== undefined) { 
                localVarFormParams.append('state', state as any);
            }
    
            if (updateMode !== undefined) { 
                localVarFormParams.append('updateMode', updateMode as any);
            }
    
            if (data !== undefined) { 
                localVarFormParams.append('data', data as any);
            }
    
            if (target !== undefined) { 
                localVarFormParams.append('target', target as any);
            }
    
            if (progress !== undefined) { 
                localVarFormParams.append('progress', progress as any);
            }
    
            if (layer !== undefined) { 
                localVarFormParams.append('layer', layer as any);
            }
    
            if (errorMessage !== undefined) { 
                localVarFormParams.append('errorMessage', errorMessage as any);
            }
    
            if (transformChain !== undefined) { 
                localVarFormParams.append('transformChain', transformChain as any);
            }
                if (messages) {
            
                localVarFormParams.append('messages', messages.join(COLLECTION_FORMATS.csv));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A PUT request over an existing task can be used to update its representation. The representation can be partial, and just contains the elements that need to be updated. The updateMode of a task normally starts as \"CREATE\", that is, create the target resource if missing. Other possible values are \"REPLACE\", that is, delete the existing features in the target layer and replace them with the task source ones, or \"APPEND\", to just add the features from the task source into an existing layer.
         * @summary Modify task with id {taskId} within import with id {importId}
         * @param {string} importId The ID of the import
         * @param {string} taskId The ID of the task
         * @param {Task} taskBody The task to create or modify
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTask: async (importId: string, taskId: string, taskBody: Task, expand?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'importId' is not null or undefined
            if (importId === null || importId === undefined) {
                throw new RequiredError('importId','Required parameter importId was null or undefined when calling putTask.');
            }
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling putTask.');
            }
            // verify required parameter 'taskBody' is not null or undefined
            if (taskBody === null || taskBody === undefined) {
                throw new RequiredError('taskBody','Required parameter taskBody was null or undefined when calling putTask.');
            }
            const localVarPath = `/imports/{importId}/tasks/{taskId}`
                .replace(`{${"importId"}}`, encodeURIComponent(String(importId)))
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof taskBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(taskBody !== undefined ? taskBody : {}) : (taskBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A new task can be created by issuing a PUT containing the raw file content to this endpoint. The name of the uploaded file will be {filename}. The location of the uploaded file will be the top level directory associated with the import, or the \"uploads\" directory in the data directory if no directory is associated with the current import.
         * @summary Create a new task
         * @param {string} importId The ID of the import
         * @param {string} filename The filename
         * @param {any} fileBody The file contents to upload.
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTaskFile: async (importId: string, filename: string, fileBody: any, expand?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'importId' is not null or undefined
            if (importId === null || importId === undefined) {
                throw new RequiredError('importId','Required parameter importId was null or undefined when calling putTaskFile.');
            }
            // verify required parameter 'filename' is not null or undefined
            if (filename === null || filename === undefined) {
                throw new RequiredError('filename','Required parameter filename was null or undefined when calling putTaskFile.');
            }
            // verify required parameter 'fileBody' is not null or undefined
            if (fileBody === null || fileBody === undefined) {
                throw new RequiredError('fileBody','Required parameter fileBody was null or undefined when calling putTaskFile.');
            }
            const localVarPath = `/imports/{importId}/tasks/{filename}`
                .replace(`{${"importId"}}`, encodeURIComponent(String(importId)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            localVarHeaderParameter['Content-Type'] = '\\*_/_*';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof fileBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(fileBody !== undefined ? fileBody : {}) : (fileBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify the target layer for a task with id {taskId} within import with id {importId}
         * @param {string} importId The ID of the import
         * @param {string} taskId The ID of the task
         * @param {Layer} layerBody The layer to modify
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTaskLayer: async (importId: string, taskId: string, layerBody: Layer, expand?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'importId' is not null or undefined
            if (importId === null || importId === undefined) {
                throw new RequiredError('importId','Required parameter importId was null or undefined when calling putTaskLayer.');
            }
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling putTaskLayer.');
            }
            // verify required parameter 'layerBody' is not null or undefined
            if (layerBody === null || layerBody === undefined) {
                throw new RequiredError('layerBody','Required parameter layerBody was null or undefined when calling putTaskLayer.');
            }
            const localVarPath = `/imports/{importId}/tasks/{taskId}/layer`
                .replace(`{${"importId"}}`, encodeURIComponent(String(importId)))
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof layerBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(layerBody !== undefined ? layerBody : {}) : (layerBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify the target store for a task with id {taskId} within import with id {importId}
         * @param {string} importId The ID of the import
         * @param {string} taskId The ID of the task
         * @param {Store} targetBody The store to modify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTaskTarget: async (importId: string, taskId: string, targetBody: Store, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'importId' is not null or undefined
            if (importId === null || importId === undefined) {
                throw new RequiredError('importId','Required parameter importId was null or undefined when calling putTaskTarget.');
            }
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling putTaskTarget.');
            }
            // verify required parameter 'targetBody' is not null or undefined
            if (targetBody === null || targetBody === undefined) {
                throw new RequiredError('targetBody','Required parameter targetBody was null or undefined when calling putTaskTarget.');
            }
            const localVarPath = `/imports/{importId}/tasks/{taskId}/target`
                .replace(`{${"importId"}}`, encodeURIComponent(String(importId)))
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof targetBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(targetBody !== undefined ? targetBody : {}) : (targetBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove task with id {taskId} within import with id {importId}
         * @param {string} importId The ID of the import
         * @param {string} taskId The ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTask(importId: string, taskId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).deleteTask(importId, taskId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve task with id {taskId} within import with id {importId}
         * @param {string} importId The ID of the import
         * @param {string} taskId The ID of the task
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTask(importId: string, taskId: string, expand?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getTask(importId, taskId, expand, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve the layer of a task with id {taskId} within import with id {importId}
         * @param {string} importId The ID of the import
         * @param {string} taskId The ID of the task
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskLayer(importId: string, taskId: string, expand?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Layer>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getTaskLayer(importId, taskId, expand, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve the current state and import progress of a task with id {taskId} within import with id {importId}
         * @param {string} importId The ID of the import
         * @param {string} taskId The ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskProgress(importId: string, taskId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Progress>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getTaskProgress(importId, taskId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve the store of a task with id {taskId} within import with id {importId}
         * @param {string} importId The ID of the import
         * @param {string} taskId The ID of the task
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskTarget(importId: string, taskId: string, expand?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Store>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getTaskTarget(importId, taskId, expand, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve all tasks for import with id {importId}
         * @param {string} importId The ID of the import
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTasks(importId: string, expand?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getTasks(importId, expand, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * A new task can be created by issuing a POST to imports/<importId>/tasks as a \"Content-type: multipart/form-data\" multipart encoded data as defined by RFC 2388. One or more file can be uploaded this way, and a task will be created for importing them. In case the file being uploaded is a zip file, it will be unzipped on the server side and treated as a directory of files. Alternatively, a new task can be created by issuing a POST as a \"Content-type: application/x-www-form-urlencoded\" form url encoded data containing a url paramerter with the location of the uploaded file.
         * @summary Create a new task
         * @param {string} importId The ID of the import
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {string} [id] The task id
         * @param {string} [href] URL to the task endpoint
         * @param {string} [state] State of the task.
         * @param {string} [updateMode] Update mode of the task.
         * @param {Data} [data] 
         * @param {Store} [target] 
         * @param {string} [progress] URL to the progress endpoint for this task
         * @param {Layer} [layer] 
         * @param {string} [errorMessage] Any error messages for the task, concatenated.
         * @param {TransformChain} [transformChain] 
         * @param {Array<object>} [messages] A list of log messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTask(importId: string, expand?: string, id?: string, href?: string, state?: string, updateMode?: string, data?: Data, target?: Store, progress?: string, layer?: Layer, errorMessage?: string, transformChain?: TransformChain, messages?: Array<object>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postTask(importId, expand, id, href, state, updateMode, data, target, progress, layer, errorMessage, transformChain, messages, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * A PUT request over an existing task can be used to update its representation. The representation can be partial, and just contains the elements that need to be updated. The updateMode of a task normally starts as \"CREATE\", that is, create the target resource if missing. Other possible values are \"REPLACE\", that is, delete the existing features in the target layer and replace them with the task source ones, or \"APPEND\", to just add the features from the task source into an existing layer.
         * @summary Modify task with id {taskId} within import with id {importId}
         * @param {string} importId The ID of the import
         * @param {string} taskId The ID of the task
         * @param {Task} taskBody The task to create or modify
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putTask(importId: string, taskId: string, taskBody: Task, expand?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).putTask(importId, taskId, taskBody, expand, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * A new task can be created by issuing a PUT containing the raw file content to this endpoint. The name of the uploaded file will be {filename}. The location of the uploaded file will be the top level directory associated with the import, or the \"uploads\" directory in the data directory if no directory is associated with the current import.
         * @summary Create a new task
         * @param {string} importId The ID of the import
         * @param {string} filename The filename
         * @param {any} fileBody The file contents to upload.
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putTaskFile(importId: string, filename: string, fileBody: any, expand?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).putTaskFile(importId, filename, fileBody, expand, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Modify the target layer for a task with id {taskId} within import with id {importId}
         * @param {string} importId The ID of the import
         * @param {string} taskId The ID of the task
         * @param {Layer} layerBody The layer to modify
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putTaskLayer(importId: string, taskId: string, layerBody: Layer, expand?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).putTaskLayer(importId, taskId, layerBody, expand, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Modify the target store for a task with id {taskId} within import with id {importId}
         * @param {string} importId The ID of the import
         * @param {string} taskId The ID of the task
         * @param {Store} targetBody The store to modify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putTaskTarget(importId: string, taskId: string, targetBody: Store, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).putTaskTarget(importId, taskId, targetBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Remove task with id {taskId} within import with id {importId}
         * @param {string} importId The ID of the import
         * @param {string} taskId The ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask(importId: string, taskId: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).deleteTask(importId, taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve task with id {taskId} within import with id {importId}
         * @param {string} importId The ID of the import
         * @param {string} taskId The ID of the task
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(importId: string, taskId: string, expand?: string, options?: any): AxiosPromise<Task> {
            return DefaultApiFp(configuration).getTask(importId, taskId, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the layer of a task with id {taskId} within import with id {importId}
         * @param {string} importId The ID of the import
         * @param {string} taskId The ID of the task
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskLayer(importId: string, taskId: string, expand?: string, options?: any): AxiosPromise<Layer> {
            return DefaultApiFp(configuration).getTaskLayer(importId, taskId, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the current state and import progress of a task with id {taskId} within import with id {importId}
         * @param {string} importId The ID of the import
         * @param {string} taskId The ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskProgress(importId: string, taskId: string, options?: any): AxiosPromise<Progress> {
            return DefaultApiFp(configuration).getTaskProgress(importId, taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the store of a task with id {taskId} within import with id {importId}
         * @param {string} importId The ID of the import
         * @param {string} taskId The ID of the task
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskTarget(importId: string, taskId: string, expand?: string, options?: any): AxiosPromise<Store> {
            return DefaultApiFp(configuration).getTaskTarget(importId, taskId, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve all tasks for import with id {importId}
         * @param {string} importId The ID of the import
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks(importId: string, expand?: string, options?: any): AxiosPromise<Array<Task>> {
            return DefaultApiFp(configuration).getTasks(importId, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * A new task can be created by issuing a POST to imports/<importId>/tasks as a \"Content-type: multipart/form-data\" multipart encoded data as defined by RFC 2388. One or more file can be uploaded this way, and a task will be created for importing them. In case the file being uploaded is a zip file, it will be unzipped on the server side and treated as a directory of files. Alternatively, a new task can be created by issuing a POST as a \"Content-type: application/x-www-form-urlencoded\" form url encoded data containing a url paramerter with the location of the uploaded file.
         * @summary Create a new task
         * @param {string} importId The ID of the import
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {string} [id] The task id
         * @param {string} [href] URL to the task endpoint
         * @param {string} [state] State of the task.
         * @param {string} [updateMode] Update mode of the task.
         * @param {Data} [data] 
         * @param {Store} [target] 
         * @param {string} [progress] URL to the progress endpoint for this task
         * @param {Layer} [layer] 
         * @param {string} [errorMessage] Any error messages for the task, concatenated.
         * @param {TransformChain} [transformChain] 
         * @param {Array<object>} [messages] A list of log messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTask(importId: string, expand?: string, id?: string, href?: string, state?: string, updateMode?: string, data?: Data, target?: Store, progress?: string, layer?: Layer, errorMessage?: string, transformChain?: TransformChain, messages?: Array<object>, options?: any): AxiosPromise<Task> {
            return DefaultApiFp(configuration).postTask(importId, expand, id, href, state, updateMode, data, target, progress, layer, errorMessage, transformChain, messages, options).then((request) => request(axios, basePath));
        },
        /**
         * A PUT request over an existing task can be used to update its representation. The representation can be partial, and just contains the elements that need to be updated. The updateMode of a task normally starts as \"CREATE\", that is, create the target resource if missing. Other possible values are \"REPLACE\", that is, delete the existing features in the target layer and replace them with the task source ones, or \"APPEND\", to just add the features from the task source into an existing layer.
         * @summary Modify task with id {taskId} within import with id {importId}
         * @param {string} importId The ID of the import
         * @param {string} taskId The ID of the task
         * @param {Task} taskBody The task to create or modify
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTask(importId: string, taskId: string, taskBody: Task, expand?: string, options?: any): AxiosPromise<Task> {
            return DefaultApiFp(configuration).putTask(importId, taskId, taskBody, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * A new task can be created by issuing a PUT containing the raw file content to this endpoint. The name of the uploaded file will be {filename}. The location of the uploaded file will be the top level directory associated with the import, or the \"uploads\" directory in the data directory if no directory is associated with the current import.
         * @summary Create a new task
         * @param {string} importId The ID of the import
         * @param {string} filename The filename
         * @param {any} fileBody The file contents to upload.
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTaskFile(importId: string, filename: string, fileBody: any, expand?: string, options?: any): AxiosPromise<Array<Task>> {
            return DefaultApiFp(configuration).putTaskFile(importId, filename, fileBody, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify the target layer for a task with id {taskId} within import with id {importId}
         * @param {string} importId The ID of the import
         * @param {string} taskId The ID of the task
         * @param {Layer} layerBody The layer to modify
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTaskLayer(importId: string, taskId: string, layerBody: Layer, expand?: string, options?: any): AxiosPromise<Task> {
            return DefaultApiFp(configuration).putTaskLayer(importId, taskId, layerBody, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify the target store for a task with id {taskId} within import with id {importId}
         * @param {string} importId The ID of the import
         * @param {string} taskId The ID of the task
         * @param {Store} targetBody The store to modify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTaskTarget(importId: string, taskId: string, targetBody: Store, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).putTaskTarget(importId, taskId, targetBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
    /**
     * 
     * @summary Remove task with id {taskId} within import with id {importId}
     * @param {string} importId The ID of the import
     * @param {string} taskId The ID of the task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    deleteTask(importId: string, taskId: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Retrieve task with id {taskId} within import with id {importId}
     * @param {string} importId The ID of the import
     * @param {string} taskId The ID of the task
     * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getTask(importId: string, taskId: string, expand?: string, options?: any): AxiosPromise<Task>;

    /**
     * 
     * @summary Retrieve the layer of a task with id {taskId} within import with id {importId}
     * @param {string} importId The ID of the import
     * @param {string} taskId The ID of the task
     * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getTaskLayer(importId: string, taskId: string, expand?: string, options?: any): AxiosPromise<Layer>;

    /**
     * 
     * @summary Retrieve the current state and import progress of a task with id {taskId} within import with id {importId}
     * @param {string} importId The ID of the import
     * @param {string} taskId The ID of the task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getTaskProgress(importId: string, taskId: string, options?: any): AxiosPromise<Progress>;

    /**
     * 
     * @summary Retrieve the store of a task with id {taskId} within import with id {importId}
     * @param {string} importId The ID of the import
     * @param {string} taskId The ID of the task
     * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getTaskTarget(importId: string, taskId: string, expand?: string, options?: any): AxiosPromise<Store>;

    /**
     * 
     * @summary Retrieve all tasks for import with id {importId}
     * @param {string} importId The ID of the import
     * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getTasks(importId: string, expand?: string, options?: any): AxiosPromise<Array<Task>>;

    /**
     * A new task can be created by issuing a POST to imports/<importId>/tasks as a \"Content-type: multipart/form-data\" multipart encoded data as defined by RFC 2388. One or more file can be uploaded this way, and a task will be created for importing them. In case the file being uploaded is a zip file, it will be unzipped on the server side and treated as a directory of files. Alternatively, a new task can be created by issuing a POST as a \"Content-type: application/x-www-form-urlencoded\" form url encoded data containing a url paramerter with the location of the uploaded file.
     * @summary Create a new task
     * @param {string} importId The ID of the import
     * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
     * @param {string} [id] The task id
     * @param {string} [href] URL to the task endpoint
     * @param {string} [state] State of the task.
     * @param {string} [updateMode] Update mode of the task.
     * @param {Data} [data] 
     * @param {Store} [target] 
     * @param {string} [progress] URL to the progress endpoint for this task
     * @param {Layer} [layer] 
     * @param {string} [errorMessage] Any error messages for the task, concatenated.
     * @param {TransformChain} [transformChain] 
     * @param {Array<object>} [messages] A list of log messages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postTask(importId: string, expand?: string, id?: string, href?: string, state?: string, updateMode?: string, data?: Data, target?: Store, progress?: string, layer?: Layer, errorMessage?: string, transformChain?: TransformChain, messages?: Array<object>, options?: any): AxiosPromise<Task>;

    /**
     * A PUT request over an existing task can be used to update its representation. The representation can be partial, and just contains the elements that need to be updated. The updateMode of a task normally starts as \"CREATE\", that is, create the target resource if missing. Other possible values are \"REPLACE\", that is, delete the existing features in the target layer and replace them with the task source ones, or \"APPEND\", to just add the features from the task source into an existing layer.
     * @summary Modify task with id {taskId} within import with id {importId}
     * @param {string} importId The ID of the import
     * @param {string} taskId The ID of the task
     * @param {Task} taskBody The task to create or modify
     * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    putTask(importId: string, taskId: string, taskBody: Task, expand?: string, options?: any): AxiosPromise<Task>;

    /**
     * A new task can be created by issuing a PUT containing the raw file content to this endpoint. The name of the uploaded file will be {filename}. The location of the uploaded file will be the top level directory associated with the import, or the \"uploads\" directory in the data directory if no directory is associated with the current import.
     * @summary Create a new task
     * @param {string} importId The ID of the import
     * @param {string} filename The filename
     * @param {any} fileBody The file contents to upload.
     * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    putTaskFile(importId: string, filename: string, fileBody: any, expand?: string, options?: any): AxiosPromise<Array<Task>>;

    /**
     * 
     * @summary Modify the target layer for a task with id {taskId} within import with id {importId}
     * @param {string} importId The ID of the import
     * @param {string} taskId The ID of the task
     * @param {Layer} layerBody The layer to modify
     * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    putTaskLayer(importId: string, taskId: string, layerBody: Layer, expand?: string, options?: any): AxiosPromise<Task>;

    /**
     * 
     * @summary Modify the target store for a task with id {taskId} within import with id {importId}
     * @param {string} importId The ID of the import
     * @param {string} taskId The ID of the task
     * @param {Store} targetBody The store to modify
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    putTaskTarget(importId: string, taskId: string, targetBody: Store, options?: any): AxiosPromise<void>;

}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
    /**
     * 
     * @summary Remove task with id {taskId} within import with id {importId}
     * @param {string} importId The ID of the import
     * @param {string} taskId The ID of the task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteTask(importId: string, taskId: string, options?: any) {
        return DefaultApiFp(this.configuration).deleteTask(importId, taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve task with id {taskId} within import with id {importId}
     * @param {string} importId The ID of the import
     * @param {string} taskId The ID of the task
     * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTask(importId: string, taskId: string, expand?: string, options?: any) {
        return DefaultApiFp(this.configuration).getTask(importId, taskId, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the layer of a task with id {taskId} within import with id {importId}
     * @param {string} importId The ID of the import
     * @param {string} taskId The ID of the task
     * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTaskLayer(importId: string, taskId: string, expand?: string, options?: any) {
        return DefaultApiFp(this.configuration).getTaskLayer(importId, taskId, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the current state and import progress of a task with id {taskId} within import with id {importId}
     * @param {string} importId The ID of the import
     * @param {string} taskId The ID of the task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTaskProgress(importId: string, taskId: string, options?: any) {
        return DefaultApiFp(this.configuration).getTaskProgress(importId, taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the store of a task with id {taskId} within import with id {importId}
     * @param {string} importId The ID of the import
     * @param {string} taskId The ID of the task
     * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTaskTarget(importId: string, taskId: string, expand?: string, options?: any) {
        return DefaultApiFp(this.configuration).getTaskTarget(importId, taskId, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve all tasks for import with id {importId}
     * @param {string} importId The ID of the import
     * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTasks(importId: string, expand?: string, options?: any) {
        return DefaultApiFp(this.configuration).getTasks(importId, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A new task can be created by issuing a POST to imports/<importId>/tasks as a \"Content-type: multipart/form-data\" multipart encoded data as defined by RFC 2388. One or more file can be uploaded this way, and a task will be created for importing them. In case the file being uploaded is a zip file, it will be unzipped on the server side and treated as a directory of files. Alternatively, a new task can be created by issuing a POST as a \"Content-type: application/x-www-form-urlencoded\" form url encoded data containing a url paramerter with the location of the uploaded file.
     * @summary Create a new task
     * @param {string} importId The ID of the import
     * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
     * @param {string} [id] The task id
     * @param {string} [href] URL to the task endpoint
     * @param {string} [state] State of the task.
     * @param {string} [updateMode] Update mode of the task.
     * @param {Data} [data] 
     * @param {Store} [target] 
     * @param {string} [progress] URL to the progress endpoint for this task
     * @param {Layer} [layer] 
     * @param {string} [errorMessage] Any error messages for the task, concatenated.
     * @param {TransformChain} [transformChain] 
     * @param {Array<object>} [messages] A list of log messages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postTask(importId: string, expand?: string, id?: string, href?: string, state?: string, updateMode?: string, data?: Data, target?: Store, progress?: string, layer?: Layer, errorMessage?: string, transformChain?: TransformChain, messages?: Array<object>, options?: any) {
        return DefaultApiFp(this.configuration).postTask(importId, expand, id, href, state, updateMode, data, target, progress, layer, errorMessage, transformChain, messages, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A PUT request over an existing task can be used to update its representation. The representation can be partial, and just contains the elements that need to be updated. The updateMode of a task normally starts as \"CREATE\", that is, create the target resource if missing. Other possible values are \"REPLACE\", that is, delete the existing features in the target layer and replace them with the task source ones, or \"APPEND\", to just add the features from the task source into an existing layer.
     * @summary Modify task with id {taskId} within import with id {importId}
     * @param {string} importId The ID of the import
     * @param {string} taskId The ID of the task
     * @param {Task} taskBody The task to create or modify
     * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putTask(importId: string, taskId: string, taskBody: Task, expand?: string, options?: any) {
        return DefaultApiFp(this.configuration).putTask(importId, taskId, taskBody, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A new task can be created by issuing a PUT containing the raw file content to this endpoint. The name of the uploaded file will be {filename}. The location of the uploaded file will be the top level directory associated with the import, or the \"uploads\" directory in the data directory if no directory is associated with the current import.
     * @summary Create a new task
     * @param {string} importId The ID of the import
     * @param {string} filename The filename
     * @param {any} fileBody The file contents to upload.
     * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putTaskFile(importId: string, filename: string, fileBody: any, expand?: string, options?: any) {
        return DefaultApiFp(this.configuration).putTaskFile(importId, filename, fileBody, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify the target layer for a task with id {taskId} within import with id {importId}
     * @param {string} importId The ID of the import
     * @param {string} taskId The ID of the task
     * @param {Layer} layerBody The layer to modify
     * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putTaskLayer(importId: string, taskId: string, layerBody: Layer, expand?: string, options?: any) {
        return DefaultApiFp(this.configuration).putTaskLayer(importId, taskId, layerBody, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify the target store for a task with id {taskId} within import with id {importId}
     * @param {string} importId The ID of the import
     * @param {string} taskId The ID of the task
     * @param {Store} targetBody The store to modify
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putTaskTarget(importId: string, taskId: string, targetBody: Store, options?: any) {
        return DefaultApiFp(this.configuration).putTaskTarget(importId, taskId, targetBody, options).then((request) => request(this.axios, this.basePath));
    }

}


