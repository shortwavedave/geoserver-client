// tslint:disable
/**
 * GeoServer Coverages
 * A coverage is a raster data set which originates from a coverage store.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: geoserver-users@sourceforge.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface CoverageInfo
 */
export interface CoverageInfo {
    /**
     * The name of the resource. This name corresponds to the \"published\" name of the resource.
     * @type {string}
     * @memberof CoverageInfo
     */
    name?: string;
    /**
     * The native name of the resource. This name corresponds to the physical resource that feature type is derived from -- a shapefile name, a database table, etc...
     * @type {string}
     * @memberof CoverageInfo
     */
    nativeName?: string;
    /**
     * 
     * @type {CoverageInfoNamespace}
     * @memberof CoverageInfo
     */
    namespace?: CoverageInfoNamespace;
    /**
     * The title of the resource. This is usually something that is meant to be displayed in a user interface.
     * @type {string}
     * @memberof CoverageInfo
     */
    title?: string;
    /**
     * A description of the resource. This is usually something that is meant to be displayed in a user interface.
     * @type {string}
     * @memberof CoverageInfo
     */
    _abstract?: string;
    /**
     * Default resampling (interpolation) method that will be used for this coverage.
     * @type {string}
     * @memberof CoverageInfo
     */
    defaultInterpolationMethod?: string;
    /**
     * 
     * @type {CoverageInfoKeywords}
     * @memberof CoverageInfo
     */
    keywords?: CoverageInfoKeywords;
    /**
     * 
     * @type {CoverageInfoMetadatalinks}
     * @memberof CoverageInfo
     */
    metadatalinks?: CoverageInfoMetadatalinks;
    /**
     * 
     * @type {CoverageInfoDataLinks}
     * @memberof CoverageInfo
     */
    dataLinks?: CoverageInfoDataLinks;
    /**
     * The native coordinate reference system object of the resource.
     * @type {string}
     * @memberof CoverageInfo
     */
    nativeCRS?: string;
    /**
     * Returns the identifier of coordinate reference system of the resource.
     * @type {string}
     * @memberof CoverageInfo
     */
    srs?: string;
    /**
     * 
     * @type {CoverageInfoNativeBoundingBox}
     * @memberof CoverageInfo
     */
    nativeBoundingBox?: CoverageInfoNativeBoundingBox;
    /**
     * 
     * @type {CoverageInfoLatLonBoundingBox}
     * @memberof CoverageInfo
     */
    latLonBoundingBox?: CoverageInfoLatLonBoundingBox;
    /**
     * A list of key/value metadata pairs.
     * @type {Array<MetadataEntry>}
     * @memberof CoverageInfo
     */
    metadata?: Array<MetadataEntry>;
    /**
     * 
     * @type {CoverageInfoStore}
     * @memberof CoverageInfo
     */
    store?: CoverageInfoStore;
    /**
     * The ECQL string used as default feature type filter
     * @type {string}
     * @memberof CoverageInfo
     */
    cqlFilter?: string;
    /**
     * A cap on the number of features that a query against this type can return.
     * @type {number}
     * @memberof CoverageInfo
     */
    maxFeatures?: number;
    /**
     * The number of decimal places to use when encoding floating point numbers from data of this feature type.
     * @type {number}
     * @memberof CoverageInfo
     */
    numDecimals?: number;
    /**
     * 
     * @type {CoverageInfoResponseSRS}
     * @memberof CoverageInfo
     */
    responseSRS?: CoverageInfoResponseSRS;
    /**
     * True if this feature type info is overriding the WFS global SRS list
     * @type {boolean}
     * @memberof CoverageInfo
     */
    overridingServiceSRS?: boolean;
    /**
     * True if this feature type info is overriding the counting of numberMatched.
     * @type {boolean}
     * @memberof CoverageInfo
     */
    skipNumberMatched?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CoverageInfo
     */
    circularArcPresent?: boolean;
    /**
     * Tolerance used to linearize this feature type, as an absolute value expressed in the geometries own CRS
     * @type {number}
     * @memberof CoverageInfo
     */
    linearizationTolerance?: number;
    /**
     * 
     * @type {CoverageInfoAttributes}
     * @memberof CoverageInfo
     */
    attributes?: CoverageInfoAttributes;
    /**
     * 
     * @type {CoverageInfoDimensions}
     * @memberof CoverageInfo
     */
    dimensions?: CoverageInfoDimensions;
    /**
     * 
     * @type {CoverageInfoGrid}
     * @memberof CoverageInfo
     */
    grid?: CoverageInfoGrid;
}
/**
 * Wrapper for the derived set of attributes for the feature type.
 * @export
 * @interface CoverageInfoAttributes
 */
export interface CoverageInfoAttributes {
    /**
     * The derived set of attributes for the feature type.
     * @type {Array<CoverageInfoAttributesAttribute>}
     * @memberof CoverageInfoAttributes
     */
    attribute?: Array<CoverageInfoAttributesAttribute>;
}
/**
 * A single attribute
 * @export
 * @interface CoverageInfoAttributesAttribute
 */
export interface CoverageInfoAttributesAttribute {
    /**
     * Name of the attribute.
     * @type {string}
     * @memberof CoverageInfoAttributesAttribute
     */
    name?: string;
    /**
     * Minimum number of occurrences of the attribute.
     * @type {number}
     * @memberof CoverageInfoAttributesAttribute
     */
    minOccurs?: number;
    /**
     * Maximum number of occurrences of the attribute.
     * @type {number}
     * @memberof CoverageInfoAttributesAttribute
     */
    maxOccurs?: number;
    /**
     * Flag indicating if null is an acceptable value for the attribute.
     * @type {boolean}
     * @memberof CoverageInfoAttributesAttribute
     */
    nillable?: boolean;
    /**
     * The java class that values of this attribute are bound to.
     * @type {string}
     * @memberof CoverageInfoAttributesAttribute
     */
    binding?: string;
    /**
     * Returns the length of this attribute. It\'s usually non null only for string and numeric types\"
     * @type {number}
     * @memberof CoverageInfoAttributesAttribute
     */
    length?: number;
}
/**
 * Wraps a collection of data links for the resource.
 * @export
 * @interface CoverageInfoDataLinks
 */
export interface CoverageInfoDataLinks {
    /**
     * A collection of data links for the resource.
     * @type {Array<CoverageInfoDataLinksMetadataLink>}
     * @memberof CoverageInfoDataLinks
     */
    metadataLink?: Array<CoverageInfoDataLinksMetadataLink>;
}
/**
 * 
 * @export
 * @interface CoverageInfoDataLinksMetadataLink
 */
export interface CoverageInfoDataLinksMetadataLink {
    /**
     * The MIME type
     * @type {string}
     * @memberof CoverageInfoDataLinksMetadataLink
     */
    type?: string;
    /**
     * The link URL
     * @type {string}
     * @memberof CoverageInfoDataLinksMetadataLink
     */
    content?: string;
}
/**
 * raster dimensions
 * @export
 * @interface CoverageInfoDimensions
 */
export interface CoverageInfoDimensions {
    /**
     * 
     * @type {Array<CoverageInfoDimensionsCoverageDimension>}
     * @memberof CoverageInfoDimensions
     */
    coverageDimension?: Array<CoverageInfoDimensionsCoverageDimension>;
}
/**
 * raster dimension
 * @export
 * @interface CoverageInfoDimensionsCoverageDimension
 */
export interface CoverageInfoDimensionsCoverageDimension {
    /**
     * description of the raster dimension
     * @type {string}
     * @memberof CoverageInfoDimensionsCoverageDimension
     */
    description?: string;
    /**
     * name of the dimension
     * @type {string}
     * @memberof CoverageInfoDimensionsCoverageDimension
     */
    name?: string;
    /**
     * 
     * @type {CoverageInfoDimensionsRange}
     * @memberof CoverageInfoDimensionsCoverageDimension
     */
    range?: CoverageInfoDimensionsRange;
}
/**
 * dimension range
 * @export
 * @interface CoverageInfoDimensionsRange
 */
export interface CoverageInfoDimensionsRange {
    /**
     * max range value
     * @type {number}
     * @memberof CoverageInfoDimensionsRange
     */
    max?: number;
    /**
     * min range value
     * @type {number}
     * @memberof CoverageInfoDimensionsRange
     */
    min?: number;
}
/**
 * contains information about how to translate from the raster plan to a coordinate reference system
 * @export
 * @interface CoverageInfoGrid
 */
export interface CoverageInfoGrid {
    /**
     * cardinality of the raster plan
     * @type {string}
     * @memberof CoverageInfoGrid
     */
    dimension?: string;
    /**
     * target coordinate system
     * @type {string}
     * @memberof CoverageInfoGrid
     */
    crs?: string;
    /**
     * 
     * @type {CoverageInfoGridRange}
     * @memberof CoverageInfoGrid
     */
    range?: CoverageInfoGridRange;
    /**
     * 
     * @type {CoverageInfoGridTransform}
     * @memberof CoverageInfoGrid
     */
    transform?: CoverageInfoGridTransform;
    /**
     * 
     * @type {CoverageInfoGridInterpolationMethods}
     * @memberof CoverageInfoGrid
     */
    interpolationMethods?: CoverageInfoGridInterpolationMethods;
}
/**
 * available interpolations methods for this coverage
 * @export
 * @interface CoverageInfoGridInterpolationMethods
 */
export interface CoverageInfoGridInterpolationMethods {
    /**
     * 
     * @type {Array<string>}
     * @memberof CoverageInfoGridInterpolationMethods
     */
    string?: Array<string>;
}
/**
 * range of the raster plan
 * @export
 * @interface CoverageInfoGridRange
 */
export interface CoverageInfoGridRange {
    /**
     * max range values
     * @type {string}
     * @memberof CoverageInfoGridRange
     */
    high?: string;
    /**
     * min range values
     * @type {string}
     * @memberof CoverageInfoGridRange
     */
    low?: string;
}
/**
 * transformation definition
 * @export
 * @interface CoverageInfoGridTransform
 */
export interface CoverageInfoGridTransform {
    /**
     * scale value to apply in X
     * @type {number}
     * @memberof CoverageInfoGridTransform
     */
    scaleX?: number;
    /**
     * scale value to apply in Y
     * @type {number}
     * @memberof CoverageInfoGridTransform
     */
    scaleY?: number;
    /**
     * shear value to apply in X
     * @type {number}
     * @memberof CoverageInfoGridTransform
     */
    shearX?: number;
    /**
     * shear value to apply in Y
     * @type {number}
     * @memberof CoverageInfoGridTransform
     */
    shearY?: number;
    /**
     * translation to apply in X
     * @type {number}
     * @memberof CoverageInfoGridTransform
     */
    translateX?: number;
    /**
     * translation to apply in Y
     * @type {number}
     * @memberof CoverageInfoGridTransform
     */
    translatexY?: number;
}
/**
 * A collection of keywords associated with the resource.
 * @export
 * @interface CoverageInfoKeywords
 */
export interface CoverageInfoKeywords {
    /**
     * List of keyword values with internationalization and vocabulary
     * @type {Array<string>}
     * @memberof CoverageInfoKeywords
     */
    string?: Array<string>;
}
/**
 * The bounds of the resource in lat / lon. This value represents a \"fixed value\" and is not calculated on the underlying dataset.
 * @export
 * @interface CoverageInfoLatLonBoundingBox
 */
export interface CoverageInfoLatLonBoundingBox {
    /**
     * The min x coordinate
     * @type {number}
     * @memberof CoverageInfoLatLonBoundingBox
     */
    minx?: number;
    /**
     * The max x coordinate
     * @type {number}
     * @memberof CoverageInfoLatLonBoundingBox
     */
    maxx?: number;
    /**
     * The min y coordinate
     * @type {number}
     * @memberof CoverageInfoLatLonBoundingBox
     */
    miny?: number;
    /**
     * The max y coordinate
     * @type {number}
     * @memberof CoverageInfoLatLonBoundingBox
     */
    maxy?: number;
    /**
     * The coordinate reference system object of the bounding box.
     * @type {string}
     * @memberof CoverageInfoLatLonBoundingBox
     */
    crs?: string;
}
/**
 * Wraps a collection of metadata links for the resource.
 * @export
 * @interface CoverageInfoMetadatalinks
 */
export interface CoverageInfoMetadatalinks {
    /**
     * A collection of metadata links for the resource.
     * @type {Array<CoverageInfoMetadatalinksMetadataLink>}
     * @memberof CoverageInfoMetadatalinks
     */
    metadataLink?: Array<CoverageInfoMetadatalinksMetadataLink>;
}
/**
 * 
 * @export
 * @interface CoverageInfoMetadatalinksMetadataLink
 */
export interface CoverageInfoMetadatalinksMetadataLink {
    /**
     * The MIME type
     * @type {string}
     * @memberof CoverageInfoMetadatalinksMetadataLink
     */
    type?: string;
    /**
     * The type of metadata, e.g. \"FGDC\"
     * @type {string}
     * @memberof CoverageInfoMetadatalinksMetadataLink
     */
    metadataType?: string;
    /**
     * The link URL
     * @type {string}
     * @memberof CoverageInfoMetadatalinksMetadataLink
     */
    content?: string;
}
/**
 * The namespace URI of the resource. Example would be an application schema namespace URI.
 * @export
 * @interface CoverageInfoNamespace
 */
export interface CoverageInfoNamespace {
    /**
     * The name of the namespace.
     * @type {string}
     * @memberof CoverageInfoNamespace
     */
    name?: string;
    /**
     * URL to the namespace.
     * @type {string}
     * @memberof CoverageInfoNamespace
     */
    href?: string;
}
/**
 * Returns the bounds of the resource in its declared CRS.
 * @export
 * @interface CoverageInfoNativeBoundingBox
 */
export interface CoverageInfoNativeBoundingBox {
    /**
     * The min x coordinate
     * @type {number}
     * @memberof CoverageInfoNativeBoundingBox
     */
    minx?: number;
    /**
     * The max x coordinate
     * @type {number}
     * @memberof CoverageInfoNativeBoundingBox
     */
    maxx?: number;
    /**
     * The min y coordinate
     * @type {number}
     * @memberof CoverageInfoNativeBoundingBox
     */
    miny?: number;
    /**
     * The max y coordinate
     * @type {number}
     * @memberof CoverageInfoNativeBoundingBox
     */
    maxy?: number;
    /**
     * The coordinate reference system object of the bounding box.
     * @type {string}
     * @memberof CoverageInfoNativeBoundingBox
     */
    crs?: string;
}
/**
 * The SRSs that the WFS service will advertise in the capabilities document for this feature type (overriding the global WFS settings).
 * @export
 * @interface CoverageInfoResponseSRS
 */
export interface CoverageInfoResponseSRS {
    /**
     * The value of the srs
     * @type {string}
     * @memberof CoverageInfoResponseSRS
     */
    string?: string;
}
/**
 * The store the resource is a part of.
 * @export
 * @interface CoverageInfoStore
 */
export interface CoverageInfoStore {
    /**
     * The class of the store
     * @type {string}
     * @memberof CoverageInfoStore
     */
    _class?: string;
    /**
     * The name of the store
     * @type {string}
     * @memberof CoverageInfoStore
     */
    name?: string;
    /**
     * URL to the data store
     * @type {string}
     * @memberof CoverageInfoStore
     */
    href?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {InlineResponse200Coverages}
     * @memberof InlineResponse200
     */
    coverages?: InlineResponse200Coverages;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {CoverageInfo}
     * @memberof InlineResponse2001
     */
    featureType?: CoverageInfo;
}
/**
 * 
 * @export
 * @interface InlineResponse200Coverages
 */
export interface InlineResponse200Coverages {
    /**
     * 
     * @type {Array<InlineResponse200CoveragesCoverage>}
     * @memberof InlineResponse200Coverages
     */
    coverage?: Array<InlineResponse200CoveragesCoverage>;
}
/**
 * 
 * @export
 * @interface InlineResponse200CoveragesCoverage
 */
export interface InlineResponse200CoveragesCoverage {
    /**
     * The Name
     * @type {string}
     * @memberof InlineResponse200CoveragesCoverage
     */
    name?: string;
    /**
     * The URL
     * @type {string}
     * @memberof InlineResponse200CoveragesCoverage
     */
    link?: string;
}
/**
 * 
 * @export
 * @interface MetadataEntry
 */
export interface MetadataEntry {
    /**
     * Key used for metadata entry, additional keys are added over time
     * @type {string}
     * @memberof MetadataEntry
     */
    key?: MetadataEntryKeyEnum;
    /**
     * Text value for provided key Valid text depends on key used. Example  {\'@key\'=\'cachingEnabled\',\'$\'=\'true\'}.
     * @type {string}
     * @memberof MetadataEntry
     */
    value?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum MetadataEntryKeyEnum {
    RegionateStrategy = 'regionateStrategy',
    RegionateFeatureLimit = 'regionateFeatureLimit',
    CacheAgeMax = 'cacheAgeMax',
    CachingEnabled = 'cachingEnabled',
    RegionateAttribute = 'regionateAttribute',
    IndexingEnabled = 'indexingEnabled',
    DirName = 'dirName'
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Invalid. Can only delete an individual coverage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoverage: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/workspaces/{workspace}/coverages/{coverage}`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalid. Can only delete an individual coverage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoverageStore: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/workspaces/{workspace}/coverages`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a coverage (optionally recursively deleting layers).
         * @param {string} workspace The name of the workspace
         * @param {string} store The name of the coverage data store
         * @param {string} coverage The name of the coverage
         * @param {boolean} [recurse] The recurse controls recursive deletion. When set to true all stores containing the resource are also removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceCoverage: async (workspace: string, store: string, coverage: string, recurse?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling deleteWorkspaceCoverage.');
            }
            // verify required parameter 'store' is not null or undefined
            if (store === null || store === undefined) {
                throw new RequiredError('store','Required parameter store was null or undefined when calling deleteWorkspaceCoverage.');
            }
            // verify required parameter 'coverage' is not null or undefined
            if (coverage === null || coverage === undefined) {
                throw new RequiredError('coverage','Required parameter coverage was null or undefined when calling deleteWorkspaceCoverage.');
            }
            const localVarPath = `/workspaces/{workspace}/coveragestores/{store}/coverages/{coverage}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"store"}}`, encodeURIComponent(String(store)))
                .replace(`{${"coverage"}}`, encodeURIComponent(String(coverage)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (recurse !== undefined) {
                localVarQueryParameter['recurse'] = recurse;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalid. Can only delete an individual coverage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceCoverageStore: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/workspaces/{workspace}/coveragestores/{store}/coverages`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an individual coverage.
         * @param {string} workspace The name of the workspace
         * @param {string} coverage The name of the coverage
         * @param {boolean} [quietOnNotFound] The quietOnNotFound parameter avoids logging an Exception when the coverage is not present. Note that 404 status code will be returned anyway.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoverage: async (workspace: string, coverage: string, quietOnNotFound?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling getCoverage.');
            }
            // verify required parameter 'coverage' is not null or undefined
            if (coverage === null || coverage === undefined) {
                throw new RequiredError('coverage','Required parameter coverage was null or undefined when calling getCoverage.');
            }
            const localVarPath = `/workspaces/{workspace}/coverages/{coverage}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"coverage"}}`, encodeURIComponent(String(coverage)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (quietOnNotFound !== undefined) {
                localVarQueryParameter['quietOnNotFound'] = quietOnNotFound;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the coverages available for the provided workspace. 
         * @param {string} workspace The name of the workspace
         * @param {'all'} [list] If the list parameter value is equal to \&quot;all\&quot; all the coverages available in the data source (even the non-published ones) will be returned. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoverageStore: async (workspace: string, list?: 'all', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling getCoverageStore.');
            }
            const localVarPath = `/workspaces/{workspace}/coverages`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (list !== undefined) {
                localVarQueryParameter['list'] = list;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an individual coverage.
         * @param {string} workspace The name of the workspace
         * @param {string} store The name of the coverage datastore
         * @param {string} coverage The name of the coverage
         * @param {boolean} [quietOnNotFound] The quietOnNotFound parameter avoids logging an Exception when the coverage is not present. Note that 404 status code will be returned anyway.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceCoverage: async (workspace: string, store: string, coverage: string, quietOnNotFound?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling getWorkspaceCoverage.');
            }
            // verify required parameter 'store' is not null or undefined
            if (store === null || store === undefined) {
                throw new RequiredError('store','Required parameter store was null or undefined when calling getWorkspaceCoverage.');
            }
            // verify required parameter 'coverage' is not null or undefined
            if (coverage === null || coverage === undefined) {
                throw new RequiredError('coverage','Required parameter coverage was null or undefined when calling getWorkspaceCoverage.');
            }
            const localVarPath = `/workspaces/{workspace}/coveragestores/{store}/coverages/{coverage}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"store"}}`, encodeURIComponent(String(store)))
                .replace(`{${"coverage"}}`, encodeURIComponent(String(coverage)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (quietOnNotFound !== undefined) {
                localVarQueryParameter['quietOnNotFound'] = quietOnNotFound;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the coverages available for the provided workspace and data store. 
         * @param {string} workspace The name of the workspace
         * @param {string} store The name of the coverage data store
         * @param {'all'} [list] If the list parameter value is equal to \&quot;all\&quot; all the coverages available in the data source (even the non-published ones) will be returned. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceCoverageStore: async (workspace: string, store: string, list?: 'all', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling getWorkspaceCoverageStore.');
            }
            // verify required parameter 'store' is not null or undefined
            if (store === null || store === undefined) {
                throw new RequiredError('store','Required parameter store was null or undefined when calling getWorkspaceCoverageStore.');
            }
            const localVarPath = `/workspaces/{workspace}/coveragestores/{store}/coverages`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"store"}}`, encodeURIComponent(String(store)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (list !== undefined) {
                localVarQueryParameter['list'] = list;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalid. Use POST on the coverages endpoint to add a new coverage, or PUT on an individual coverage to edit it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCoverage: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/workspaces/{workspace}/coverages/{coverage}`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new coverage, the coverage definition needs to reference a store. 
         * @param {string} workspace The name of the workspace
         * @param {CoverageInfo} coverage The body of the coverage to POST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCoverageStore: async (workspace: string, coverage: CoverageInfo, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling postCoverageStore.');
            }
            // verify required parameter 'coverage' is not null or undefined
            if (coverage === null || coverage === undefined) {
                throw new RequiredError('coverage','Required parameter coverage was null or undefined when calling postCoverageStore.');
            }
            const localVarPath = `/workspaces/{workspace}/coverages`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof coverage !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(coverage !== undefined ? coverage : {}) : (coverage || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalid. Use POST on the coverages endpoint to add a new coverage, or PUT on an individual coverage to edit it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWorkspaceCoverage: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/workspaces/{workspace}/coveragestores/{store}/coverages/{coverage}`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new coverage, the underlying data store must exist. 
         * @param {string} workspace The name of the workspace
         * @param {string} store The name of the coverage data store
         * @param {CoverageInfo} coverage The body of the coverage to POST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWorkspaceCoverageStore: async (workspace: string, store: string, coverage: CoverageInfo, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling postWorkspaceCoverageStore.');
            }
            // verify required parameter 'store' is not null or undefined
            if (store === null || store === undefined) {
                throw new RequiredError('store','Required parameter store was null or undefined when calling postWorkspaceCoverageStore.');
            }
            // verify required parameter 'coverage' is not null or undefined
            if (coverage === null || coverage === undefined) {
                throw new RequiredError('coverage','Required parameter coverage was null or undefined when calling postWorkspaceCoverageStore.');
            }
            const localVarPath = `/workspaces/{workspace}/coveragestores/{store}/coverages`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"store"}}`, encodeURIComponent(String(store)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof coverage !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(coverage !== undefined ? coverage : {}) : (coverage || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalid. Use POST for adding a new coverage, or PUT on an individual coverage to edit that type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCoverage: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/workspaces/{workspace}/coverages/{coverage}`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalid. Use POST for adding a new coverage, or PUT on an individual coverage to edit that type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCoverageStore: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/workspaces/{workspace}/coverages`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an individual coverage
         * @param {string} workspace The name of the workspace
         * @param {string} store The name of the coverage data store
         * @param {string} coverage The name of the coverage
         * @param {CoverageInfo} coverage The body of the coverage to PUT
         * @param {Array<'nativebbox' | 'latlonbbox'>} [calculate] Comma-separated list of optional fields to calculate. Optional fields include: \&quot;nativebbox\&quot;, \&quot;latlonbbox\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWorkspaceCoverage: async (workspace: string, store: string, coverage: string, coverage: CoverageInfo, calculate?: Array<'nativebbox' | 'latlonbbox'>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling putWorkspaceCoverage.');
            }
            // verify required parameter 'store' is not null or undefined
            if (store === null || store === undefined) {
                throw new RequiredError('store','Required parameter store was null or undefined when calling putWorkspaceCoverage.');
            }
            // verify required parameter 'coverage' is not null or undefined
            if (coverage === null || coverage === undefined) {
                throw new RequiredError('coverage','Required parameter coverage was null or undefined when calling putWorkspaceCoverage.');
            }
            // verify required parameter 'coverage' is not null or undefined
            if (coverage === null || coverage === undefined) {
                throw new RequiredError('coverage','Required parameter coverage was null or undefined when calling putWorkspaceCoverage.');
            }
            const localVarPath = `/workspaces/{workspace}/coveragestores/{store}/coverages/{coverage}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"store"}}`, encodeURIComponent(String(store)))
                .replace(`{${"coverage"}}`, encodeURIComponent(String(coverage)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (calculate) {
                localVarQueryParameter['calculate'] = calculate.join(COLLECTION_FORMATS.csv);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/xml';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof coverage !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(coverage !== undefined ? coverage : {}) : (coverage || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalid. Use POST for adding a new coverage, or PUT on an individual coverage to edit that type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWorkspaceCoverageStore: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/workspaces/{workspace}/coveragestores/{store}/coverages`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Invalid. Can only delete an individual coverage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCoverage(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).deleteCoverage(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Invalid. Can only delete an individual coverage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCoverageStore(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).deleteCoverageStore(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a coverage (optionally recursively deleting layers).
         * @param {string} workspace The name of the workspace
         * @param {string} store The name of the coverage data store
         * @param {string} coverage The name of the coverage
         * @param {boolean} [recurse] The recurse controls recursive deletion. When set to true all stores containing the resource are also removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspaceCoverage(workspace: string, store: string, coverage: string, recurse?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).deleteWorkspaceCoverage(workspace, store, coverage, recurse, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Invalid. Can only delete an individual coverage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspaceCoverageStore(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).deleteWorkspaceCoverageStore(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get an individual coverage.
         * @param {string} workspace The name of the workspace
         * @param {string} coverage The name of the coverage
         * @param {boolean} [quietOnNotFound] The quietOnNotFound parameter avoids logging an Exception when the coverage is not present. Note that 404 status code will be returned anyway.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCoverage(workspace: string, coverage: string, quietOnNotFound?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getCoverage(workspace, coverage, quietOnNotFound, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the coverages available for the provided workspace. 
         * @param {string} workspace The name of the workspace
         * @param {'all'} [list] If the list parameter value is equal to \&quot;all\&quot; all the coverages available in the data source (even the non-published ones) will be returned. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCoverageStore(workspace: string, list?: 'all', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getCoverageStore(workspace, list, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get an individual coverage.
         * @param {string} workspace The name of the workspace
         * @param {string} store The name of the coverage datastore
         * @param {string} coverage The name of the coverage
         * @param {boolean} [quietOnNotFound] The quietOnNotFound parameter avoids logging an Exception when the coverage is not present. Note that 404 status code will be returned anyway.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceCoverage(workspace: string, store: string, coverage: string, quietOnNotFound?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getWorkspaceCoverage(workspace, store, coverage, quietOnNotFound, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the coverages available for the provided workspace and data store. 
         * @param {string} workspace The name of the workspace
         * @param {string} store The name of the coverage data store
         * @param {'all'} [list] If the list parameter value is equal to \&quot;all\&quot; all the coverages available in the data source (even the non-published ones) will be returned. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceCoverageStore(workspace: string, store: string, list?: 'all', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getWorkspaceCoverageStore(workspace, store, list, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Invalid. Use POST on the coverages endpoint to add a new coverage, or PUT on an individual coverage to edit it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCoverage(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postCoverage(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new coverage, the coverage definition needs to reference a store. 
         * @param {string} workspace The name of the workspace
         * @param {CoverageInfo} coverage The body of the coverage to POST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCoverageStore(workspace: string, coverage: CoverageInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postCoverageStore(workspace, coverage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Invalid. Use POST on the coverages endpoint to add a new coverage, or PUT on an individual coverage to edit it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWorkspaceCoverage(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postWorkspaceCoverage(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new coverage, the underlying data store must exist. 
         * @param {string} workspace The name of the workspace
         * @param {string} store The name of the coverage data store
         * @param {CoverageInfo} coverage The body of the coverage to POST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWorkspaceCoverageStore(workspace: string, store: string, coverage: CoverageInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postWorkspaceCoverageStore(workspace, store, coverage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Invalid. Use POST for adding a new coverage, or PUT on an individual coverage to edit that type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCoverage(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).putCoverage(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Invalid. Use POST for adding a new coverage, or PUT on an individual coverage to edit that type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCoverageStore(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).putCoverageStore(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update an individual coverage
         * @param {string} workspace The name of the workspace
         * @param {string} store The name of the coverage data store
         * @param {string} coverage The name of the coverage
         * @param {CoverageInfo} coverage The body of the coverage to PUT
         * @param {Array<'nativebbox' | 'latlonbbox'>} [calculate] Comma-separated list of optional fields to calculate. Optional fields include: \&quot;nativebbox\&quot;, \&quot;latlonbbox\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putWorkspaceCoverage(workspace: string, store: string, coverage: string, coverage: CoverageInfo, calculate?: Array<'nativebbox' | 'latlonbbox'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).putWorkspaceCoverage(workspace, store, coverage, coverage, calculate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Invalid. Use POST for adding a new coverage, or PUT on an individual coverage to edit that type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putWorkspaceCoverageStore(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).putWorkspaceCoverageStore(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Invalid. Can only delete an individual coverage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoverage(options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).deleteCoverage(options).then((request) => request(axios, basePath));
        },
        /**
         * Invalid. Can only delete an individual coverage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoverageStore(options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).deleteCoverageStore(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a coverage (optionally recursively deleting layers).
         * @param {string} workspace The name of the workspace
         * @param {string} store The name of the coverage data store
         * @param {string} coverage The name of the coverage
         * @param {boolean} [recurse] The recurse controls recursive deletion. When set to true all stores containing the resource are also removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceCoverage(workspace: string, store: string, coverage: string, recurse?: boolean, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).deleteWorkspaceCoverage(workspace, store, coverage, recurse, options).then((request) => request(axios, basePath));
        },
        /**
         * Invalid. Can only delete an individual coverage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceCoverageStore(options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).deleteWorkspaceCoverageStore(options).then((request) => request(axios, basePath));
        },
        /**
         * Get an individual coverage.
         * @param {string} workspace The name of the workspace
         * @param {string} coverage The name of the coverage
         * @param {boolean} [quietOnNotFound] The quietOnNotFound parameter avoids logging an Exception when the coverage is not present. Note that 404 status code will be returned anyway.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoverage(workspace: string, coverage: string, quietOnNotFound?: boolean, options?: any): AxiosPromise<InlineResponse2001> {
            return DefaultApiFp(configuration).getCoverage(workspace, coverage, quietOnNotFound, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the coverages available for the provided workspace. 
         * @param {string} workspace The name of the workspace
         * @param {'all'} [list] If the list parameter value is equal to \&quot;all\&quot; all the coverages available in the data source (even the non-published ones) will be returned. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoverageStore(workspace: string, list?: 'all', options?: any): AxiosPromise<InlineResponse200> {
            return DefaultApiFp(configuration).getCoverageStore(workspace, list, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an individual coverage.
         * @param {string} workspace The name of the workspace
         * @param {string} store The name of the coverage datastore
         * @param {string} coverage The name of the coverage
         * @param {boolean} [quietOnNotFound] The quietOnNotFound parameter avoids logging an Exception when the coverage is not present. Note that 404 status code will be returned anyway.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceCoverage(workspace: string, store: string, coverage: string, quietOnNotFound?: boolean, options?: any): AxiosPromise<InlineResponse2001> {
            return DefaultApiFp(configuration).getWorkspaceCoverage(workspace, store, coverage, quietOnNotFound, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the coverages available for the provided workspace and data store. 
         * @param {string} workspace The name of the workspace
         * @param {string} store The name of the coverage data store
         * @param {'all'} [list] If the list parameter value is equal to \&quot;all\&quot; all the coverages available in the data source (even the non-published ones) will be returned. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceCoverageStore(workspace: string, store: string, list?: 'all', options?: any): AxiosPromise<InlineResponse200> {
            return DefaultApiFp(configuration).getWorkspaceCoverageStore(workspace, store, list, options).then((request) => request(axios, basePath));
        },
        /**
         * Invalid. Use POST on the coverages endpoint to add a new coverage, or PUT on an individual coverage to edit it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCoverage(options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).postCoverage(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new coverage, the coverage definition needs to reference a store. 
         * @param {string} workspace The name of the workspace
         * @param {CoverageInfo} coverage The body of the coverage to POST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCoverageStore(workspace: string, coverage: CoverageInfo, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).postCoverageStore(workspace, coverage, options).then((request) => request(axios, basePath));
        },
        /**
         * Invalid. Use POST on the coverages endpoint to add a new coverage, or PUT on an individual coverage to edit it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWorkspaceCoverage(options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).postWorkspaceCoverage(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new coverage, the underlying data store must exist. 
         * @param {string} workspace The name of the workspace
         * @param {string} store The name of the coverage data store
         * @param {CoverageInfo} coverage The body of the coverage to POST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWorkspaceCoverageStore(workspace: string, store: string, coverage: CoverageInfo, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).postWorkspaceCoverageStore(workspace, store, coverage, options).then((request) => request(axios, basePath));
        },
        /**
         * Invalid. Use POST for adding a new coverage, or PUT on an individual coverage to edit that type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCoverage(options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).putCoverage(options).then((request) => request(axios, basePath));
        },
        /**
         * Invalid. Use POST for adding a new coverage, or PUT on an individual coverage to edit that type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCoverageStore(options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).putCoverageStore(options).then((request) => request(axios, basePath));
        },
        /**
         * Update an individual coverage
         * @param {string} workspace The name of the workspace
         * @param {string} store The name of the coverage data store
         * @param {string} coverage The name of the coverage
         * @param {CoverageInfo} coverage The body of the coverage to PUT
         * @param {Array<'nativebbox' | 'latlonbbox'>} [calculate] Comma-separated list of optional fields to calculate. Optional fields include: \&quot;nativebbox\&quot;, \&quot;latlonbbox\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWorkspaceCoverage(workspace: string, store: string, coverage: string, coverage: CoverageInfo, calculate?: Array<'nativebbox' | 'latlonbbox'>, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).putWorkspaceCoverage(workspace, store, coverage, coverage, calculate, options).then((request) => request(axios, basePath));
        },
        /**
         * Invalid. Use POST for adding a new coverage, or PUT on an individual coverage to edit that type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWorkspaceCoverageStore(options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).putWorkspaceCoverageStore(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
    /**
     * Invalid. Can only delete an individual coverage.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    deleteCoverage(options?: any): AxiosPromise<void>;

    /**
     * Invalid. Can only delete an individual coverage.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    deleteCoverageStore(options?: any): AxiosPromise<void>;

    /**
     * Delete a coverage (optionally recursively deleting layers).
     * @param {string} workspace The name of the workspace
     * @param {string} store The name of the coverage data store
     * @param {string} coverage The name of the coverage
     * @param {boolean} [recurse] The recurse controls recursive deletion. When set to true all stores containing the resource are also removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    deleteWorkspaceCoverage(workspace: string, store: string, coverage: string, recurse?: boolean, options?: any): AxiosPromise<void>;

    /**
     * Invalid. Can only delete an individual coverage.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    deleteWorkspaceCoverageStore(options?: any): AxiosPromise<void>;

    /**
     * Get an individual coverage.
     * @param {string} workspace The name of the workspace
     * @param {string} coverage The name of the coverage
     * @param {boolean} [quietOnNotFound] The quietOnNotFound parameter avoids logging an Exception when the coverage is not present. Note that 404 status code will be returned anyway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getCoverage(workspace: string, coverage: string, quietOnNotFound?: boolean, options?: any): AxiosPromise<InlineResponse2001>;

    /**
     * Get the coverages available for the provided workspace. 
     * @param {string} workspace The name of the workspace
     * @param {'all'} [list] If the list parameter value is equal to \&quot;all\&quot; all the coverages available in the data source (even the non-published ones) will be returned. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getCoverageStore(workspace: string, list?: 'all', options?: any): AxiosPromise<InlineResponse200>;

    /**
     * Get an individual coverage.
     * @param {string} workspace The name of the workspace
     * @param {string} store The name of the coverage datastore
     * @param {string} coverage The name of the coverage
     * @param {boolean} [quietOnNotFound] The quietOnNotFound parameter avoids logging an Exception when the coverage is not present. Note that 404 status code will be returned anyway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getWorkspaceCoverage(workspace: string, store: string, coverage: string, quietOnNotFound?: boolean, options?: any): AxiosPromise<InlineResponse2001>;

    /**
     * Get the coverages available for the provided workspace and data store. 
     * @param {string} workspace The name of the workspace
     * @param {string} store The name of the coverage data store
     * @param {'all'} [list] If the list parameter value is equal to \&quot;all\&quot; all the coverages available in the data source (even the non-published ones) will be returned. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getWorkspaceCoverageStore(workspace: string, store: string, list?: 'all', options?: any): AxiosPromise<InlineResponse200>;

    /**
     * Invalid. Use POST on the coverages endpoint to add a new coverage, or PUT on an individual coverage to edit it.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postCoverage(options?: any): AxiosPromise<void>;

    /**
     * Create a new coverage, the coverage definition needs to reference a store. 
     * @param {string} workspace The name of the workspace
     * @param {CoverageInfo} coverage The body of the coverage to POST
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postCoverageStore(workspace: string, coverage: CoverageInfo, options?: any): AxiosPromise<void>;

    /**
     * Invalid. Use POST on the coverages endpoint to add a new coverage, or PUT on an individual coverage to edit it.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postWorkspaceCoverage(options?: any): AxiosPromise<void>;

    /**
     * Create a new coverage, the underlying data store must exist. 
     * @param {string} workspace The name of the workspace
     * @param {string} store The name of the coverage data store
     * @param {CoverageInfo} coverage The body of the coverage to POST
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postWorkspaceCoverageStore(workspace: string, store: string, coverage: CoverageInfo, options?: any): AxiosPromise<void>;

    /**
     * Invalid. Use POST for adding a new coverage, or PUT on an individual coverage to edit that type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    putCoverage(options?: any): AxiosPromise<void>;

    /**
     * Invalid. Use POST for adding a new coverage, or PUT on an individual coverage to edit that type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    putCoverageStore(options?: any): AxiosPromise<void>;

    /**
     * Update an individual coverage
     * @param {string} workspace The name of the workspace
     * @param {string} store The name of the coverage data store
     * @param {string} coverage The name of the coverage
     * @param {CoverageInfo} coverage The body of the coverage to PUT
     * @param {Array<'nativebbox' | 'latlonbbox'>} [calculate] Comma-separated list of optional fields to calculate. Optional fields include: \&quot;nativebbox\&quot;, \&quot;latlonbbox\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    putWorkspaceCoverage(workspace: string, store: string, coverage: string, coverage: CoverageInfo, calculate?: Array<'nativebbox' | 'latlonbbox'>, options?: any): AxiosPromise<void>;

    /**
     * Invalid. Use POST for adding a new coverage, or PUT on an individual coverage to edit that type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    putWorkspaceCoverageStore(options?: any): AxiosPromise<void>;

}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
    /**
     * Invalid. Can only delete an individual coverage.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteCoverage(options?: any) {
        return DefaultApiFp(this.configuration).deleteCoverage(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invalid. Can only delete an individual coverage.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteCoverageStore(options?: any) {
        return DefaultApiFp(this.configuration).deleteCoverageStore(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a coverage (optionally recursively deleting layers).
     * @param {string} workspace The name of the workspace
     * @param {string} store The name of the coverage data store
     * @param {string} coverage The name of the coverage
     * @param {boolean} [recurse] The recurse controls recursive deletion. When set to true all stores containing the resource are also removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteWorkspaceCoverage(workspace: string, store: string, coverage: string, recurse?: boolean, options?: any) {
        return DefaultApiFp(this.configuration).deleteWorkspaceCoverage(workspace, store, coverage, recurse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invalid. Can only delete an individual coverage.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteWorkspaceCoverageStore(options?: any) {
        return DefaultApiFp(this.configuration).deleteWorkspaceCoverageStore(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an individual coverage.
     * @param {string} workspace The name of the workspace
     * @param {string} coverage The name of the coverage
     * @param {boolean} [quietOnNotFound] The quietOnNotFound parameter avoids logging an Exception when the coverage is not present. Note that 404 status code will be returned anyway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCoverage(workspace: string, coverage: string, quietOnNotFound?: boolean, options?: any) {
        return DefaultApiFp(this.configuration).getCoverage(workspace, coverage, quietOnNotFound, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the coverages available for the provided workspace. 
     * @param {string} workspace The name of the workspace
     * @param {'all'} [list] If the list parameter value is equal to \&quot;all\&quot; all the coverages available in the data source (even the non-published ones) will be returned. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCoverageStore(workspace: string, list?: 'all', options?: any) {
        return DefaultApiFp(this.configuration).getCoverageStore(workspace, list, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an individual coverage.
     * @param {string} workspace The name of the workspace
     * @param {string} store The name of the coverage datastore
     * @param {string} coverage The name of the coverage
     * @param {boolean} [quietOnNotFound] The quietOnNotFound parameter avoids logging an Exception when the coverage is not present. Note that 404 status code will be returned anyway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getWorkspaceCoverage(workspace: string, store: string, coverage: string, quietOnNotFound?: boolean, options?: any) {
        return DefaultApiFp(this.configuration).getWorkspaceCoverage(workspace, store, coverage, quietOnNotFound, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the coverages available for the provided workspace and data store. 
     * @param {string} workspace The name of the workspace
     * @param {string} store The name of the coverage data store
     * @param {'all'} [list] If the list parameter value is equal to \&quot;all\&quot; all the coverages available in the data source (even the non-published ones) will be returned. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getWorkspaceCoverageStore(workspace: string, store: string, list?: 'all', options?: any) {
        return DefaultApiFp(this.configuration).getWorkspaceCoverageStore(workspace, store, list, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invalid. Use POST on the coverages endpoint to add a new coverage, or PUT on an individual coverage to edit it.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postCoverage(options?: any) {
        return DefaultApiFp(this.configuration).postCoverage(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new coverage, the coverage definition needs to reference a store. 
     * @param {string} workspace The name of the workspace
     * @param {CoverageInfo} coverage The body of the coverage to POST
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postCoverageStore(workspace: string, coverage: CoverageInfo, options?: any) {
        return DefaultApiFp(this.configuration).postCoverageStore(workspace, coverage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invalid. Use POST on the coverages endpoint to add a new coverage, or PUT on an individual coverage to edit it.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postWorkspaceCoverage(options?: any) {
        return DefaultApiFp(this.configuration).postWorkspaceCoverage(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new coverage, the underlying data store must exist. 
     * @param {string} workspace The name of the workspace
     * @param {string} store The name of the coverage data store
     * @param {CoverageInfo} coverage The body of the coverage to POST
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postWorkspaceCoverageStore(workspace: string, store: string, coverage: CoverageInfo, options?: any) {
        return DefaultApiFp(this.configuration).postWorkspaceCoverageStore(workspace, store, coverage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invalid. Use POST for adding a new coverage, or PUT on an individual coverage to edit that type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putCoverage(options?: any) {
        return DefaultApiFp(this.configuration).putCoverage(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invalid. Use POST for adding a new coverage, or PUT on an individual coverage to edit that type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putCoverageStore(options?: any) {
        return DefaultApiFp(this.configuration).putCoverageStore(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an individual coverage
     * @param {string} workspace The name of the workspace
     * @param {string} store The name of the coverage data store
     * @param {string} coverage The name of the coverage
     * @param {CoverageInfo} coverage The body of the coverage to PUT
     * @param {Array<'nativebbox' | 'latlonbbox'>} [calculate] Comma-separated list of optional fields to calculate. Optional fields include: \&quot;nativebbox\&quot;, \&quot;latlonbbox\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putWorkspaceCoverage(workspace: string, store: string, coverage: string, coverage: CoverageInfo, calculate?: Array<'nativebbox' | 'latlonbbox'>, options?: any) {
        return DefaultApiFp(this.configuration).putWorkspaceCoverage(workspace, store, coverage, coverage, calculate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invalid. Use POST for adding a new coverage, or PUT on an individual coverage to edit that type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putWorkspaceCoverageStore(options?: any) {
        return DefaultApiFp(this.configuration).putWorkspaceCoverageStore(options).then((request) => request(this.axios, this.basePath));
    }

}


