// tslint:disable
/**
 * GeoServer Importer Extension - Main
 * The Importer extension gives a GeoServer administrator an alternate, more-streamlined method for uploading and configuring new layers. The main endpoint manages individual import jobs. The importer extension is an optional install and may not be available on all deployments of GeoServer
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: geoserver-users@sourceforge.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * A data transform that maps an attribute from one type to another.
 * @export
 * @interface AttributeRemapTransform
 */
export interface AttributeRemapTransform {
    /**
     * \"AttributeRemapTransform\"
     * @type {string}
     * @memberof AttributeRemapTransform
     */
    type?: string;
    /**
     * URL to the transform endpoint
     * @type {string}
     * @memberof AttributeRemapTransform
     */
    href?: string;
    /**
     * The field to remap.
     * @type {string}
     * @memberof AttributeRemapTransform
     */
    field?: string;
    /**
     * The type to map the attribute to.
     * @type {string}
     * @memberof AttributeRemapTransform
     */
    target?: string;
}
/**
 * A data transform that maps two numerical attributes to a point geometry.
 * @export
 * @interface AttributesToPointGeometryTransform
 */
export interface AttributesToPointGeometryTransform {
    /**
     * \"AttributesToPointGeometryTransform\"
     * @type {string}
     * @memberof AttributesToPointGeometryTransform
     */
    type?: string;
    /**
     * URL to the transform endpoint
     * @type {string}
     * @memberof AttributesToPointGeometryTransform
     */
    href?: string;
    /**
     * The field used for the lattitude
     * @type {string}
     * @memberof AttributesToPointGeometryTransform
     */
    latField?: string;
    /**
     * The field used for the longitude
     * @type {string}
     * @memberof AttributesToPointGeometryTransform
     */
    lonField?: string;
}
/**
 * A spatially referenced bounding box.
 * @export
 * @interface Bbox
 */
export interface Bbox {
    /**
     * The minimum x value
     * @type {string}
     * @memberof Bbox
     */
    minx?: string;
    /**
     * The minimum y value
     * @type {string}
     * @memberof Bbox
     */
    miny?: string;
    /**
     * The maximum x value
     * @type {string}
     * @memberof Bbox
     */
    maxx?: string;
    /**
     * The maximum y value
     * @type {string}
     * @memberof Bbox
     */
    maxy?: string;
    /**
     * The WKT representation of the CRS.
     * @type {string}
     * @memberof Bbox
     */
    crs?: string;
}
/**
 * An import context
 * @export
 * @interface Context
 */
export interface Context {
    /**
     * The import id
     * @type {string}
     * @memberof Context
     */
    id?: string;
    /**
     * URL to the import context endpoint
     * @type {string}
     * @memberof Context
     */
    href?: string;
    /**
     * State of the import.
     * @type {string}
     * @memberof Context
     */
    state?: ContextStateEnum;
    /**
     * The current context message, if any
     * @type {string}
     * @memberof Context
     */
    message?: string;
    /**
     * Flag to control whether imported files (indirect) should be archived after import
     * @type {boolean}
     * @memberof Context
     */
    archive?: boolean;
    /**
     * Target workspace of the import, if any.
     * @type {string}
     * @memberof Context
     */
    targetWorkspace?: string;
    /**
     * 
     * @type {Store}
     * @memberof Context
     */
    targetStore?: Store;
    /**
     * 
     * @type {Data}
     * @memberof Context
     */
    data?: Data;
    /**
     * A list of transforms
     * @type {Array<Transform>}
     * @memberof Context
     */
    transforms?: Array<Transform>;
    /**
     * A list of tasks
     * @type {Array<Task>}
     * @memberof Context
     */
    tasks?: Array<Task>;
}

/**
    * @export
    * @enum {string}
    */
export enum ContextStateEnum {
    INIT = 'INIT',
    INITERROR = 'INIT_ERROR',
    PENDING = 'PENDING',
    RUNNING = 'RUNNING',
    COMPLETE = 'COMPLETE'
}

/**
 * A raster store
 * @export
 * @interface CoverageStore
 */
export interface CoverageStore {
    /**
     * URL to the task target endpoint
     * @type {string}
     * @memberof CoverageStore
     */
    href?: string;
    /**
     * 
     * @type {CoverageStoreCoverageStore}
     * @memberof CoverageStore
     */
    coverageStore?: CoverageStoreCoverageStore;
}
/**
 * 
 * @export
 * @interface CoverageStoreCoverageStore
 */
export interface CoverageStoreCoverageStore {
    /**
     * Name of the coverage store
     * @type {string}
     * @memberof CoverageStoreCoverageStore
     */
    name: string;
    /**
     * Description of the coverage store
     * @type {string}
     * @memberof CoverageStoreCoverageStore
     */
    description?: string;
    /**
     * Type of coverage store
     * @type {string}
     * @memberof CoverageStoreCoverageStore
     */
    type: string;
    /**
     * Whether the store is enabled, or not
     * @type {boolean}
     * @memberof CoverageStoreCoverageStore
     */
    enabled?: boolean;
    /**
     * 
     * @type {CoverageStoreCoverageStoreWorkspace}
     * @memberof CoverageStoreCoverageStore
     */
    workspace?: CoverageStoreCoverageStoreWorkspace;
    /**
     * Whether the store is the default store of the workspace
     * @type {boolean}
     * @memberof CoverageStoreCoverageStore
     */
    __default__?: boolean;
    /**
     * Location of the raster data source (often, but not necessarily, a file). Can be relative to the data directory.
     * @type {string}
     * @memberof CoverageStoreCoverageStore
     */
    url?: string;
    /**
     * 
     * @type {CoverageStoreCoverageStoreCoverages}
     * @memberof CoverageStoreCoverageStore
     */
    coverages?: CoverageStoreCoverageStoreCoverages;
}
/**
 * 
 * @export
 * @interface CoverageStoreCoverageStoreCoverages
 */
export interface CoverageStoreCoverageStoreCoverages {
    /**
     * A link to the list of coverages contained in this store
     * @type {string}
     * @memberof CoverageStoreCoverageStoreCoverages
     */
    link?: string;
}
/**
 * The workspace containing the store
 * @export
 * @interface CoverageStoreCoverageStoreWorkspace
 */
export interface CoverageStoreCoverageStoreWorkspace {
    /**
     * Name of the workspace
     * @type {string}
     * @memberof CoverageStoreCoverageStoreWorkspace
     */
    name: string;
    /**
     * A link to the workspace representation
     * @type {string}
     * @memberof CoverageStoreCoverageStoreWorkspace
     */
    link?: string;
}
/**
 * A data transform that creates an index in the data (assuming the import data is a database).
 * @export
 * @interface CreateIndexTransform
 */
export interface CreateIndexTransform {
    /**
     * \"CreateIndexTransform\"
     * @type {string}
     * @memberof CreateIndexTransform
     */
    type?: string;
    /**
     * URL to the transform endpoint
     * @type {string}
     * @memberof CreateIndexTransform
     */
    href?: string;
    /**
     * The field to create the index for
     * @type {string}
     * @memberof CreateIndexTransform
     */
    field?: string;
}
/**
 * A data representation. Paramaters vary depending on the type.
 * @export
 * @interface Data
 */
export interface Data {
    /**
     * The type of the data
     * @type {string}
     * @memberof Data
     */
    type?: DataTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum DataTypeEnum {
    Remote = 'remote',
    File = 'file',
    Directory = 'directory',
    Mosaic = 'mosaic',
    Database = 'database',
    Table = 'table'
}

/**
 * A data transform that converts a non date attribute in a date attribute.
 * @export
 * @interface DataFormatTransform
 */
export interface DataFormatTransform {
    /**
     * \"DataFormatTransform\"
     * @type {string}
     * @memberof DataFormatTransform
     */
    type?: string;
    /**
     * URL to the transform endpoint
     * @type {string}
     * @memberof DataFormatTransform
     */
    href?: string;
    /**
     * The field to apply the transform to
     * @type {string}
     * @memberof DataFormatTransform
     */
    field?: string;
    /**
     * A date parsing pattern, setup using the Java SimpleDateFormat syntax. In case it\'s missing, a number of built-in formats will be tried instead (short and full ISO date formats, dates without any separators).
     * @type {string}
     * @memberof DataFormatTransform
     */
    format?: string;
}
/**
 * A vector store
 * @export
 * @interface DataStore
 */
export interface DataStore {
    /**
     * URL to the task target endpoint
     * @type {string}
     * @memberof DataStore
     */
    href?: string;
    /**
     * 
     * @type {Datastore}
     * @memberof DataStore
     */
    datastore?: Datastore;
}
/**
 * An import data object representing a database
 * @export
 * @interface Database
 */
export interface Database {
    /**
     * \"database\"
     * @type {string}
     * @memberof Database
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    format?: string;
    /**
     * URL to the database endpoint
     * @type {string}
     * @memberof Database
     */
    href?: string;
    /**
     * Database connection parameters. Actual paramaters vary depending on the type of database.
     * @type {object}
     * @memberof Database
     */
    properties?: object;
    /**
     * 
     * @type {Array<Table>}
     * @memberof Database
     */
    tables?: Array<Table>;
}
/**
 * 
 * @export
 * @interface Datastore
 */
export interface Datastore {
    /**
     * Name of data store
     * @type {string}
     * @memberof Datastore
     */
    name?: string;
    /**
     * URL to data store definition
     * @type {string}
     * @memberof Datastore
     */
    link?: string;
}
/**
 * An import data object representing a directory of spatial files or an image mosaic
 * @export
 * @interface Directory
 */
export interface Directory {
    /**
     * \"directory\" or \"mosaic\"
     * @type {string}
     * @memberof Directory
     */
    type?: string;
    /**
     * Absolute system path to the directory
     * @type {string}
     * @memberof Directory
     */
    location?: string;
    /**
     * URL to the directory endpoint
     * @type {string}
     * @memberof Directory
     */
    href?: string;
    /**
     * Charset encoding of the data
     * @type {string}
     * @memberof Directory
     */
    charset?: string;
    /**
     * List of file descriptors
     * @type {Array<FileContents>}
     * @memberof Directory
     */
    files?: Array<FileContents>;
}
/**
 * Description of a spatial file or granule
 * @export
 * @interface FileContents
 */
export interface FileContents {
    /**
     * Name of the file
     * @type {string}
     * @memberof FileContents
     */
    file?: string;
    /**
     * URL to the file endpoint
     * @type {string}
     * @memberof FileContents
     */
    href?: string;
    /**
     * Name of the .prj file, if applicable
     * @type {string}
     * @memberof FileContents
     */
    prj?: string;
    /**
     * List of other files that comprise this spatial file.
     * @type {Array<string>}
     * @memberof FileContents
     */
    other?: Array<string>;
}
/**
 * A data transform that runs gdaladdo on a input raster file.
 * @export
 * @interface GdalAddoTransform
 */
export interface GdalAddoTransform {
    /**
     * \"GdalAddoTransform\"
     * @type {string}
     * @memberof GdalAddoTransform
     */
    type?: string;
    /**
     * URL to the transform endpoint
     * @type {string}
     * @memberof GdalAddoTransform
     */
    href?: string;
    /**
     * Array of options that are passed to gdal when running the transform
     * @type {Array<string>}
     * @memberof GdalAddoTransform
     */
    options?: Array<string>;
    /**
     * The levels
     * @type {Array<number>}
     * @memberof GdalAddoTransform
     */
    levels?: Array<number>;
}
/**
 * A data transform that runs gdal_translate on a input raster file.
 * @export
 * @interface GdalTranslateTransform
 */
export interface GdalTranslateTransform {
    /**
     * \"GdalTranslateTransform\"
     * @type {string}
     * @memberof GdalTranslateTransform
     */
    type?: string;
    /**
     * URL to the transform endpoint
     * @type {string}
     * @memberof GdalTranslateTransform
     */
    href?: string;
    /**
     * Array of options that are passed to gdal when running the transform
     * @type {Array<string>}
     * @memberof GdalTranslateTransform
     */
    options?: Array<string>;
}
/**
 * A data transform that runs gdalwarp on a input raster file.
 * @export
 * @interface GdalWarpTransform
 */
export interface GdalWarpTransform {
    /**
     * \"GdalWarpTransform\"
     * @type {string}
     * @memberof GdalWarpTransform
     */
    type?: string;
    /**
     * URL to the transform endpoint
     * @type {string}
     * @memberof GdalWarpTransform
     */
    href?: string;
    /**
     * Array of options that are passed to gdal when running the transform
     * @type {Array<string>}
     * @memberof GdalWarpTransform
     */
    options?: Array<string>;
}
/**
 * A data transform that allows a string or number field to be used as a year Date. The number is interpreted as an Integer.
 * @export
 * @interface IntegerFieldToDateTransform
 */
export interface IntegerFieldToDateTransform {
    /**
     * \"IntegerFieldToDateTransform\"
     * @type {string}
     * @memberof IntegerFieldToDateTransform
     */
    type?: string;
    /**
     * URL to the transform endpoint
     * @type {string}
     * @memberof IntegerFieldToDateTransform
     */
    href?: string;
    /**
     * The field to apply the transform to
     * @type {string}
     * @memberof IntegerFieldToDateTransform
     */
    field?: string;
}
/**
 * A layer
 * @export
 * @interface Layer
 */
export interface Layer {
    /**
     * The name of the layer
     * @type {string}
     * @memberof Layer
     */
    name?: string;
    /**
     * URL to the importer layer endpoint
     * @type {string}
     * @memberof Layer
     */
    href?: string;
    /**
     * The layer title
     * @type {string}
     * @memberof Layer
     */
    title?: string;
    /**
     * The layer abstract
     * @type {string}
     * @memberof Layer
     */
    _abstract?: string;
    /**
     * The layer description
     * @type {string}
     * @memberof Layer
     */
    description?: string;
    /**
     * The original name of the layer. This may be different from the name if this name already exists in geoserver.
     * @type {string}
     * @memberof Layer
     */
    originalName?: string;
    /**
     * The name of the underlying resource
     * @type {string}
     * @memberof Layer
     */
    nativeName?: string;
    /**
     * The SRS of the layer
     * @type {string}
     * @memberof Layer
     */
    srs?: string;
    /**
     * 
     * @type {Bbox}
     * @memberof Layer
     */
    bbox?: Bbox;
    /**
     * Feature type attributes
     * @type {Array<object>}
     * @memberof Layer
     */
    attributes?: Array<object>;
    /**
     * 
     * @type {Style}
     * @memberof Layer
     */
    style?: Style;
}
/**
 * An import data object representing a spatial file or granule
 * @export
 * @interface ModelFile
 */
export interface ModelFile {
    /**
     * \"file\"
     * @type {string}
     * @memberof ModelFile
     */
    type?: string;
    /**
     * Format of the file
     * @type {string}
     * @memberof ModelFile
     */
    format?: string;
    /**
     * URL to the file endpoint
     * @type {string}
     * @memberof ModelFile
     */
    href?: string;
    /**
     * Absolute system path to the file
     * @type {string}
     * @memberof ModelFile
     */
    location?: string;
    /**
     * The charset encoding of the data
     * @type {string}
     * @memberof ModelFile
     */
    charset?: string;
    /**
     * Name of the file
     * @type {string}
     * @memberof ModelFile
     */
    file?: string;
    /**
     * Name of the .prj file, if applicable
     * @type {string}
     * @memberof ModelFile
     */
    prj?: string;
    /**
     * List of other files that comprise this spatial file.
     * @type {Array<string>}
     * @memberof ModelFile
     */
    other?: Array<string>;
    /**
     * A message about the import data.
     * @type {string}
     * @memberof ModelFile
     */
    message?: string;
}
/**
 * Invokes a script found in $GEOSERVER_DATA_DIR/importer/scripts
 * @export
 * @interface PostScriptTransform
 */
export interface PostScriptTransform {
    /**
     * \"PostScriptTransform\"
     * @type {string}
     * @memberof PostScriptTransform
     */
    type?: string;
    /**
     * URL to the transform endpoint
     * @type {string}
     * @memberof PostScriptTransform
     */
    href?: string;
    /**
     * The name of the script to be invoked
     * @type {string}
     * @memberof PostScriptTransform
     */
    name?: string;
    /**
     * Array of options that are passed to the script when running the transform
     * @type {Array<string>}
     * @memberof PostScriptTransform
     */
    options?: Array<string>;
}
/**
 * An import data object representing remote data.
 * @export
 * @interface Remote
 */
export interface Remote {
    /**
     * \"remote\"
     * @type {string}
     * @memberof Remote
     */
    type?: string;
    /**
     * The location from which to fetch the data.
     * @type {string}
     * @memberof Remote
     */
    location?: string;
    /**
     * Username required to access the data (optional).
     * @type {string}
     * @memberof Remote
     */
    username?: string;
    /**
     * Password required to access the data (optional).
     * @type {string}
     * @memberof Remote
     */
    password?: string;
    /**
     * domain of the data.
     * @type {string}
     * @memberof Remote
     */
    domain?: string;
}
/**
 * A data transform that reprojects the geometry from one CRS to another.
 * @export
 * @interface ReprojectTransform
 */
export interface ReprojectTransform {
    /**
     * \"ReprojectTransform\"
     * @type {string}
     * @memberof ReprojectTransform
     */
    type?: string;
    /**
     * URL to the transform endpoint
     * @type {string}
     * @memberof ReprojectTransform
     */
    href?: string;
    /**
     * The CRS to reproject from
     * @type {string}
     * @memberof ReprojectTransform
     */
    source?: string;
    /**
     * The CRS to reproject to
     * @type {string}
     * @memberof ReprojectTransform
     */
    target?: string;
}
/**
 * A store
 * @export
 * @interface Store
 */
export interface Store {
    /**
     * URL to the task target endpoint
     * @type {string}
     * @memberof Store
     */
    href?: string;
    /**
     * JSON representation of the store
     * @type {object}
     * @memberof Store
     */
    store?: object;
}
/**
 * A layer style
 * @export
 * @interface Style
 */
export interface Style {
    /**
     * Name of the style
     * @type {string}
     * @memberof Style
     */
    name?: string;
    /**
     * URL to the importer layer style endpoint
     * @type {string}
     * @memberof Style
     */
    href?: string;
    /**
     * Format of style
     * @type {string}
     * @memberof Style
     */
    format?: string;
    /**
     * 
     * @type {StyleLanguageVersion}
     * @memberof Style
     */
    languageVersion?: StyleLanguageVersion;
    /**
     * File name of the style
     * @type {string}
     * @memberof Style
     */
    filename?: string;
}
/**
 * 
 * @export
 * @interface StyleLanguageVersion
 */
export interface StyleLanguageVersion {
    /**
     * Version of style format
     * @type {string}
     * @memberof StyleLanguageVersion
     */
    version?: string;
}
/**
 * An import data object representing a a database table
 * @export
 * @interface Table
 */
export interface Table {
    /**
     * \"table\"
     * @type {string}
     * @memberof Table
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof Table
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Table
     */
    format?: string;
    /**
     * URL to the table endpoint
     * @type {string}
     * @memberof Table
     */
    href?: string;
}
/**
 * An import task
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * The task id
     * @type {string}
     * @memberof Task
     */
    id?: string;
    /**
     * URL to the task endpoint
     * @type {string}
     * @memberof Task
     */
    href?: string;
    /**
     * State of the task.
     * @type {string}
     * @memberof Task
     */
    state?: TaskStateEnum;
    /**
     * Update mode of the task.
     * @type {string}
     * @memberof Task
     */
    updateMode?: TaskUpdateModeEnum;
    /**
     * 
     * @type {Data}
     * @memberof Task
     */
    data?: Data;
    /**
     * 
     * @type {Store}
     * @memberof Task
     */
    target?: Store;
    /**
     * URL to the progress endpoint for this task
     * @type {string}
     * @memberof Task
     */
    progress?: string;
    /**
     * 
     * @type {Layer}
     * @memberof Task
     */
    layer?: Layer;
    /**
     * Any error messages for the task, concatenated.
     * @type {string}
     * @memberof Task
     */
    errorMessage?: string;
    /**
     * 
     * @type {TransformChain}
     * @memberof Task
     */
    transformChain?: TransformChain;
    /**
     * A list of log messages
     * @type {Array<object>}
     * @memberof Task
     */
    messages?: Array<object>;
}

/**
    * @export
    * @enum {string}
    */
export enum TaskStateEnum {
    PENDING = 'PENDING',
    READY = 'READY',
    RUNNING = 'RUNNING',
    NOCRS = 'NO_CRS',
    NOBOUNDS = 'NO_BOUNDS',
    NOFORMAT = 'NO_FORMAT',
    BADFORMAT = 'BAD_FORMAT',
    ERROR = 'ERROR',
    CANCELED = 'CANCELED',
    COMPLETE = 'COMPLETE'
}
/**
    * @export
    * @enum {string}
    */
export enum TaskUpdateModeEnum {
    CREATE = 'CREATE',
    REPLACE = 'REPLACE',
    APPEND = 'APPEND',
    UPDATE = 'UPDATE'
}

/**
 * A data transform applied to the import data.
 * @export
 * @interface Transform
 */
export interface Transform {
    /**
     * The name of the transform
     * @type {string}
     * @memberof Transform
     */
    type?: string;
    /**
     * URL to the transform endpoint
     * @type {string}
     * @memberof Transform
     */
    href?: string;
}
/**
 * A chain of tranform operations to apply during the import process
 * @export
 * @interface TransformChain
 */
export interface TransformChain {
    /**
     * The type of transforms in the chain. One of \"vector\" or \"raster\"
     * @type {string}
     * @memberof TransformChain
     */
    type?: string;
    /**
     * A list of transforms
     * @type {Array<Transform>}
     * @memberof TransformChain
     */
    transforms?: Array<Transform>;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the import with id {importId}, as long as it is not in the COMPLETE state.
         * @summary Delete an import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImport: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/imports/{importId}`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes all imports that are not in the COMPLETE state.
         * @summary Delete all imports
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImports: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/imports`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve import by id
         * @param {string} importId The ID of the import
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImport: async (importId: string, expand?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'importId' is not null or undefined
            if (importId === null || importId === undefined) {
                throw new RequiredError('importId','Required parameter importId was null or undefined when calling getImport.');
            }
            const localVarPath = `/imports/{importId}`
                .replace(`{${"importId"}}`, encodeURIComponent(String(importId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all imports
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImports: async (expand?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/imports`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If an import with the id {importId} exists and is not in the INIT state, it is executed. If an import with that id does not exist, a new import is created with that id. If the exec parameter is true, this new import is immediately executed.
         * @summary Create a new import, or execute an existing import
         * @param {Context} importBody The import context to create.
         * @param {boolean} [async] Run the import asyncronously.
         * @param {boolean} [exec] Run the import when it is created.
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postImport: async (importBody: Context, async?: boolean, exec?: boolean, expand?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'importBody' is not null or undefined
            if (importBody === null || importBody === undefined) {
                throw new RequiredError('importBody','Required parameter importBody was null or undefined when calling postImport.');
            }
            const localVarPath = `/imports/{importId}`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (async !== undefined) {
                localVarQueryParameter['async'] = async;
            }

            if (exec !== undefined) {
                localVarQueryParameter['exec'] = exec;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof importBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(importBody !== undefined ? importBody : {}) : (importBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new import. If the exec parameter is true, that import is immediately executed.
         * @summary Create a new import
         * @param {Context} importBody The import context to create.
         * @param {boolean} [async] Run the import asyncronously.
         * @param {boolean} [exec] Run the import when it is created.
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postImports: async (importBody: Context, async?: boolean, exec?: boolean, expand?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'importBody' is not null or undefined
            if (importBody === null || importBody === undefined) {
                throw new RequiredError('importBody','Required parameter importBody was null or undefined when calling postImports.');
            }
            const localVarPath = `/imports`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (async !== undefined) {
                localVarQueryParameter['async'] = async;
            }

            if (exec !== undefined) {
                localVarQueryParameter['exec'] = exec;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof importBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(importBody !== undefined ? importBody : {}) : (importBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new import with the next unclaimed id >= {importId}. If the exec parameter is true, that import is immediately executed.
         * @summary Tries to create a new import with the provided id.
         * @param {Context} importBody The import context to create.
         * @param {boolean} [async] Run the import asyncronously.
         * @param {boolean} [exec] Run the import when it is created.
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putImport: async (importBody: Context, async?: boolean, exec?: boolean, expand?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'importBody' is not null or undefined
            if (importBody === null || importBody === undefined) {
                throw new RequiredError('importBody','Required parameter importBody was null or undefined when calling putImport.');
            }
            const localVarPath = `/imports/{importId}`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (async !== undefined) {
                localVarQueryParameter['async'] = async;
            }

            if (exec !== undefined) {
                localVarQueryParameter['exec'] = exec;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof importBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(importBody !== undefined ? importBody : {}) : (importBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes the import with id {importId}, as long as it is not in the COMPLETE state.
         * @summary Delete an import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteImport(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).deleteImport(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes all imports that are not in the COMPLETE state.
         * @summary Delete all imports
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteImports(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).deleteImports(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve import by id
         * @param {string} importId The ID of the import
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImport(importId: string, expand?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Context>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getImport(importId, expand, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a list of all imports
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImports(expand?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Context>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getImports(expand, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * If an import with the id {importId} exists and is not in the INIT state, it is executed. If an import with that id does not exist, a new import is created with that id. If the exec parameter is true, this new import is immediately executed.
         * @summary Create a new import, or execute an existing import
         * @param {Context} importBody The import context to create.
         * @param {boolean} [async] Run the import asyncronously.
         * @param {boolean} [exec] Run the import when it is created.
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postImport(importBody: Context, async?: boolean, exec?: boolean, expand?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Context>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postImport(importBody, async, exec, expand, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new import. If the exec parameter is true, that import is immediately executed.
         * @summary Create a new import
         * @param {Context} importBody The import context to create.
         * @param {boolean} [async] Run the import asyncronously.
         * @param {boolean} [exec] Run the import when it is created.
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postImports(importBody: Context, async?: boolean, exec?: boolean, expand?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Context>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postImports(importBody, async, exec, expand, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new import with the next unclaimed id >= {importId}. If the exec parameter is true, that import is immediately executed.
         * @summary Tries to create a new import with the provided id.
         * @param {Context} importBody The import context to create.
         * @param {boolean} [async] Run the import asyncronously.
         * @param {boolean} [exec] Run the import when it is created.
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putImport(importBody: Context, async?: boolean, exec?: boolean, expand?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Context>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).putImport(importBody, async, exec, expand, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Deletes the import with id {importId}, as long as it is not in the COMPLETE state.
         * @summary Delete an import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImport(options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).deleteImport(options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes all imports that are not in the COMPLETE state.
         * @summary Delete all imports
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImports(options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).deleteImports(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve import by id
         * @param {string} importId The ID of the import
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImport(importId: string, expand?: string, options?: any): AxiosPromise<Context> {
            return DefaultApiFp(configuration).getImport(importId, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of all imports
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImports(expand?: string, options?: any): AxiosPromise<Array<Context>> {
            return DefaultApiFp(configuration).getImports(expand, options).then((request) => request(axios, basePath));
        },
        /**
         * If an import with the id {importId} exists and is not in the INIT state, it is executed. If an import with that id does not exist, a new import is created with that id. If the exec parameter is true, this new import is immediately executed.
         * @summary Create a new import, or execute an existing import
         * @param {Context} importBody The import context to create.
         * @param {boolean} [async] Run the import asyncronously.
         * @param {boolean} [exec] Run the import when it is created.
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postImport(importBody: Context, async?: boolean, exec?: boolean, expand?: string, options?: any): AxiosPromise<Context> {
            return DefaultApiFp(configuration).postImport(importBody, async, exec, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new import. If the exec parameter is true, that import is immediately executed.
         * @summary Create a new import
         * @param {Context} importBody The import context to create.
         * @param {boolean} [async] Run the import asyncronously.
         * @param {boolean} [exec] Run the import when it is created.
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postImports(importBody: Context, async?: boolean, exec?: boolean, expand?: string, options?: any): AxiosPromise<Context> {
            return DefaultApiFp(configuration).postImports(importBody, async, exec, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new import with the next unclaimed id >= {importId}. If the exec parameter is true, that import is immediately executed.
         * @summary Tries to create a new import with the provided id.
         * @param {Context} importBody The import context to create.
         * @param {boolean} [async] Run the import asyncronously.
         * @param {boolean} [exec] Run the import when it is created.
         * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putImport(importBody: Context, async?: boolean, exec?: boolean, expand?: string, options?: any): AxiosPromise<Context> {
            return DefaultApiFp(configuration).putImport(importBody, async, exec, expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
    /**
     * Deletes the import with id {importId}, as long as it is not in the COMPLETE state.
     * @summary Delete an import
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    deleteImport(options?: any): AxiosPromise<void>;

    /**
     * Deletes all imports that are not in the COMPLETE state.
     * @summary Delete all imports
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    deleteImports(options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Retrieve import by id
     * @param {string} importId The ID of the import
     * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getImport(importId: string, expand?: string, options?: any): AxiosPromise<Context>;

    /**
     * 
     * @summary Get a list of all imports
     * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getImports(expand?: string, options?: any): AxiosPromise<Array<Context>>;

    /**
     * If an import with the id {importId} exists and is not in the INIT state, it is executed. If an import with that id does not exist, a new import is created with that id. If the exec parameter is true, this new import is immediately executed.
     * @summary Create a new import, or execute an existing import
     * @param {Context} importBody The import context to create.
     * @param {boolean} [async] Run the import asyncronously.
     * @param {boolean} [exec] Run the import when it is created.
     * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postImport(importBody: Context, async?: boolean, exec?: boolean, expand?: string, options?: any): AxiosPromise<Context>;

    /**
     * Creates a new import. If the exec parameter is true, that import is immediately executed.
     * @summary Create a new import
     * @param {Context} importBody The import context to create.
     * @param {boolean} [async] Run the import asyncronously.
     * @param {boolean} [exec] Run the import when it is created.
     * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postImports(importBody: Context, async?: boolean, exec?: boolean, expand?: string, options?: any): AxiosPromise<Context>;

    /**
     * Creates a new import with the next unclaimed id >= {importId}. If the exec parameter is true, that import is immediately executed.
     * @summary Tries to create a new import with the provided id.
     * @param {Context} importBody The import context to create.
     * @param {boolean} [async] Run the import asyncronously.
     * @param {boolean} [exec] Run the import when it is created.
     * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    putImport(importBody: Context, async?: boolean, exec?: boolean, expand?: string, options?: any): AxiosPromise<Context>;

}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
    /**
     * Deletes the import with id {importId}, as long as it is not in the COMPLETE state.
     * @summary Delete an import
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteImport(options?: any) {
        return DefaultApiFp(this.configuration).deleteImport(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes all imports that are not in the COMPLETE state.
     * @summary Delete all imports
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteImports(options?: any) {
        return DefaultApiFp(this.configuration).deleteImports(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve import by id
     * @param {string} importId The ID of the import
     * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getImport(importId: string, expand?: string, options?: any) {
        return DefaultApiFp(this.configuration).getImport(importId, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of all imports
     * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getImports(expand?: string, options?: any) {
        return DefaultApiFp(this.configuration).getImports(expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If an import with the id {importId} exists and is not in the INIT state, it is executed. If an import with that id does not exist, a new import is created with that id. If the exec parameter is true, this new import is immediately executed.
     * @summary Create a new import, or execute an existing import
     * @param {Context} importBody The import context to create.
     * @param {boolean} [async] Run the import asyncronously.
     * @param {boolean} [exec] Run the import when it is created.
     * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postImport(importBody: Context, async?: boolean, exec?: boolean, expand?: string, options?: any) {
        return DefaultApiFp(this.configuration).postImport(importBody, async, exec, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new import. If the exec parameter is true, that import is immediately executed.
     * @summary Create a new import
     * @param {Context} importBody The import context to create.
     * @param {boolean} [async] Run the import asyncronously.
     * @param {boolean} [exec] Run the import when it is created.
     * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postImports(importBody: Context, async?: boolean, exec?: boolean, expand?: string, options?: any) {
        return DefaultApiFp(this.configuration).postImports(importBody, async, exec, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new import with the next unclaimed id >= {importId}. If the exec parameter is true, that import is immediately executed.
     * @summary Tries to create a new import with the provided id.
     * @param {Context} importBody The import context to create.
     * @param {boolean} [async] Run the import asyncronously.
     * @param {boolean} [exec] Run the import when it is created.
     * @param {string} [expand] What level to expand the response object to. Can be \&quot;self\&quot; (expand only the response object and its immediate children), \&quot;all\&quot; (expand all children), \&quot;none\&quot; (don\&#39;t include any children), or a nonnegative integer, indicating the depth of children to expand to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putImport(importBody: Context, async?: boolean, exec?: boolean, expand?: string, options?: any) {
        return DefaultApiFp(this.configuration).putImport(importBody, async, exec, expand, options).then((request) => request(this.axios, this.basePath));
    }

}


