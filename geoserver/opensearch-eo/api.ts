// tslint:disable
/**
 * OpenSearch for EO search index access
 * Allows to manipulate the OpenSearch for EO index
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: geoserver-users@sourceforge.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a collection and everything inside it
         * @param {string} collection Identifier of the collection
         * @param {boolean} [keepMetadata] When present and set to true, makes GeoServer un-publish the collection (removal of OGC links, removal of associated layer) without removing the metadata. The collection remains searchable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionDelete: async (collection: string, keepMetadata?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionDelete.');
            }
            const localVarPath = `/collections/{collection}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keepMetadata !== undefined) {
                localVarQueryParameter['keepMetadata'] = keepMetadata;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the collection HTML description
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionDescriptionDelete: async (collection: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionDescriptionDelete.');
            }
            const localVarPath = `/collections/{collection}/description`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the HTML description of this collection
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionDescriptionGet: async (collection: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionDescriptionGet.');
            }
            const localVarPath = `/collections/{collection}/description`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates/creates a collection HTML description
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionDescriptionPut: async (collection: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionDescriptionPut.');
            }
            const localVarPath = `/collections/{collection}/description`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a collection search attributes and its ogc links
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionGet: async (collection: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionGet.');
            }
            const localVarPath = `/collections/{collection}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the mosaic configuration, store, layer and style associated to this collection
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionLayerDelete: async (collection: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionLayerDelete.');
            }
            const localVarPath = `/collections/{collection}/layer`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the current publishing configuration for the layer (or 404 if no configuration is currently in use)
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionLayerGet: async (collection: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionLayerGet.');
            }
            const localVarPath = `/collections/{collection}/layer`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the previous publshing configuration and replaces with a new one, creating along the mosaic configuration, store, layer and style as described
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionLayerPut: async (collection: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionLayerPut.');
            }
            const localVarPath = `/collections/{collection}/layer`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of collection layers
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionLayersGet: async (collection: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionLayersGet.');
            }
            const localVarPath = `/collections/{collection}/layers`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the collection layer configuration
         * @param {string} collection Identifier of the collection
         * @param {string} layer Identifier of the layer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionLayersLayerDelete: async (collection: string, layer: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionLayersLayerDelete.');
            }
            // verify required parameter 'layer' is not null or undefined
            if (layer === null || layer === undefined) {
                throw new RequiredError('layer','Required parameter layer was null or undefined when calling collectionsCollectionLayersLayerDelete.');
            }
            const localVarPath = `/collections/{collection}/layers/{layer}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"layer"}}`, encodeURIComponent(String(layer)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of collection layers
         * @param {string} collection Identifier of the collection
         * @param {string} layer Identifier of the layer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionLayersLayerGet: async (collection: string, layer: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionLayersLayerGet.');
            }
            // verify required parameter 'layer' is not null or undefined
            if (layer === null || layer === undefined) {
                throw new RequiredError('layer','Required parameter layer was null or undefined when calling collectionsCollectionLayersLayerGet.');
            }
            const localVarPath = `/collections/{collection}/layers/{layer}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"layer"}}`, encodeURIComponent(String(layer)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates/creates a collection layer publishing configuration
         * @param {string} collection Identifier of the collection
         * @param {string} layer Identifier of the layer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionLayersLayerPut: async (collection: string, layer: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionLayersLayerPut.');
            }
            // verify required parameter 'layer' is not null or undefined
            if (layer === null || layer === undefined) {
                throw new RequiredError('layer','Required parameter layer was null or undefined when calling collectionsCollectionLayersLayerPut.');
            }
            const localVarPath = `/collections/{collection}/layers/{layer}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"layer"}}`, encodeURIComponent(String(layer)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the product metadata
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionMetadataDelete: async (collection: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionMetadataDelete.');
            }
            const localVarPath = `/collections/{collection}/metadata`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the ISO metadata of this collection
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionMetadataGet: async (collection: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionMetadataGet.');
            }
            const localVarPath = `/collections/{collection}/metadata`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates/creates a collection ISO metadata
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionMetadataPut: async (collection: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionMetadataPut.');
            }
            const localVarPath = `/collections/{collection}/metadata`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the collection OGC links
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionOgcLinksDelete: async (collection: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionOgcLinksDelete.');
            }
            const localVarPath = `/collections/{collection}/ogcLinks`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of OGC links
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionOgcLinksGet: async (collection: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionOgcLinksGet.');
            }
            const localVarPath = `/collections/{collection}/ogcLinks`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates/creates a collection OGC links
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionOgcLinksPut: async (collection: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionOgcLinksPut.');
            }
            const localVarPath = `/collections/{collection}/ogcLinks`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paged list of all available products
         * @param {string} collection Identifier of the collection
         * @param {number} [offset] First element for paged responses
         * @param {number} [limit] Number of elements in page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsGet: async (collection: string, offset?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionProductsGet.');
            }
            const localVarPath = `/collections/{collection}/products`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new product via its search attributes and ogc links. The zip format accepts  a set of files creating the collection in a single shot, and will contain the following files:  * product.json: the list of searchable attributes and eventual OGC links * description.html: the HTML description for the product * metadata.xml: the O&M metadata for the collection * thumbnail.png: the product thumbnail (can also have jpeg or jpg extension) * owsLinks.json: the list of OWS links, in the same JSON format as the associated resource  * granules.json: the list of granules, in the same JSON format as the associated resource The JSON format is the same as the one returned by a GET on an existing product, the \"*Href\" properties should be omitted  
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsPost: async (collection: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionProductsPost.');
            }
            const localVarPath = `/collections/{collection}/products`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a product and everything inside it
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {boolean} [keepMetadata] When present and set to true, makes GeoServer un-publish the product (removal of OGC links, direct download location and granule references) without removing the metadata. The product remains searchable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductDelete: async (collection: string, product: string, keepMetadata?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionProductsProductDelete.');
            }
            // verify required parameter 'product' is not null or undefined
            if (product === null || product === undefined) {
                throw new RequiredError('product','Required parameter product was null or undefined when calling collectionsCollectionProductsProductDelete.');
            }
            const localVarPath = `/collections/{collection}/products/{product}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"product"}}`, encodeURIComponent(String(product)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keepMetadata !== undefined) {
                localVarQueryParameter['keepMetadata'] = keepMetadata;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the product HTML description
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductDescriptionDelete: async (collection: string, product: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionProductsProductDescriptionDelete.');
            }
            // verify required parameter 'product' is not null or undefined
            if (product === null || product === undefined) {
                throw new RequiredError('product','Required parameter product was null or undefined when calling collectionsCollectionProductsProductDescriptionDelete.');
            }
            const localVarPath = `/collections/{collection}/products/{product}/description`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"product"}}`, encodeURIComponent(String(product)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the HTML description of this product
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductDescriptionGet: async (collection: string, product: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionProductsProductDescriptionGet.');
            }
            // verify required parameter 'product' is not null or undefined
            if (product === null || product === undefined) {
                throw new RequiredError('product','Required parameter product was null or undefined when calling collectionsCollectionProductsProductDescriptionGet.');
            }
            const localVarPath = `/collections/{collection}/products/{product}/description`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"product"}}`, encodeURIComponent(String(product)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates/creates a product HTML description
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductDescriptionPut: async (collection: string, product: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionProductsProductDescriptionPut.');
            }
            // verify required parameter 'product' is not null or undefined
            if (product === null || product === undefined) {
                throw new RequiredError('product','Required parameter product was null or undefined when calling collectionsCollectionProductsProductDescriptionPut.');
            }
            const localVarPath = `/collections/{collection}/products/{product}/description`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"product"}}`, encodeURIComponent(String(product)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a product search attributes, ogc links and granules. The response contains cross links to ogcLinks/metadata/description/thumnail/granules sub-resources, when the same JSON is used o create a new collection the associated can be omitted, or if everything needs to be put in the JSON, the associated representations can be inlined instead (the thumbnail image can be BASE64 encded). A creation with ZIP is recommend. 
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductGet: async (collection: string, product: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionProductsProductGet.');
            }
            // verify required parameter 'product' is not null or undefined
            if (product === null || product === undefined) {
                throw new RequiredError('product','Required parameter product was null or undefined when calling collectionsCollectionProductsProductGet.');
            }
            const localVarPath = `/collections/{collection}/products/{product}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"product"}}`, encodeURIComponent(String(product)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the product OGC links
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductGranulesDelete: async (collection: string, product: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionProductsProductGranulesDelete.');
            }
            // verify required parameter 'product' is not null or undefined
            if (product === null || product === undefined) {
                throw new RequiredError('product','Required parameter product was null or undefined when calling collectionsCollectionProductsProductGranulesDelete.');
            }
            const localVarPath = `/collections/{collection}/products/{product}/granules`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"product"}}`, encodeURIComponent(String(product)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of a product granules
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductGranulesGet: async (collection: string, product: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionProductsProductGranulesGet.');
            }
            // verify required parameter 'product' is not null or undefined
            if (product === null || product === undefined) {
                throw new RequiredError('product','Required parameter product was null or undefined when calling collectionsCollectionProductsProductGranulesGet.');
            }
            const localVarPath = `/collections/{collection}/products/{product}/granules`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"product"}}`, encodeURIComponent(String(product)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates/creates a product granules
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductGranulesPut: async (collection: string, product: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionProductsProductGranulesPut.');
            }
            // verify required parameter 'product' is not null or undefined
            if (product === null || product === undefined) {
                throw new RequiredError('product','Required parameter product was null or undefined when calling collectionsCollectionProductsProductGranulesPut.');
            }
            const localVarPath = `/collections/{collection}/products/{product}/granules`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"product"}}`, encodeURIComponent(String(product)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the product metadata
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductMetadataDelete: async (collection: string, product: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionProductsProductMetadataDelete.');
            }
            // verify required parameter 'product' is not null or undefined
            if (product === null || product === undefined) {
                throw new RequiredError('product','Required parameter product was null or undefined when calling collectionsCollectionProductsProductMetadataDelete.');
            }
            const localVarPath = `/collections/{collection}/products/{product}/metadata`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"product"}}`, encodeURIComponent(String(product)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the O&M metadata of this product
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductMetadataGet: async (collection: string, product: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionProductsProductMetadataGet.');
            }
            // verify required parameter 'product' is not null or undefined
            if (product === null || product === undefined) {
                throw new RequiredError('product','Required parameter product was null or undefined when calling collectionsCollectionProductsProductMetadataGet.');
            }
            const localVarPath = `/collections/{collection}/products/{product}/metadata`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"product"}}`, encodeURIComponent(String(product)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates/creates a product O&M metadata
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductMetadataPut: async (collection: string, product: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionProductsProductMetadataPut.');
            }
            // verify required parameter 'product' is not null or undefined
            if (product === null || product === undefined) {
                throw new RequiredError('product','Required parameter product was null or undefined when calling collectionsCollectionProductsProductMetadataPut.');
            }
            const localVarPath = `/collections/{collection}/products/{product}/metadata`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"product"}}`, encodeURIComponent(String(product)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the product OGC links
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductOgcLinksDelete: async (collection: string, product: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionProductsProductOgcLinksDelete.');
            }
            // verify required parameter 'product' is not null or undefined
            if (product === null || product === undefined) {
                throw new RequiredError('product','Required parameter product was null or undefined when calling collectionsCollectionProductsProductOgcLinksDelete.');
            }
            const localVarPath = `/collections/{collection}/products/{product}/ogcLinks`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"product"}}`, encodeURIComponent(String(product)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of a product OGC links
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductOgcLinksGet: async (collection: string, product: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionProductsProductOgcLinksGet.');
            }
            // verify required parameter 'product' is not null or undefined
            if (product === null || product === undefined) {
                throw new RequiredError('product','Required parameter product was null or undefined when calling collectionsCollectionProductsProductOgcLinksGet.');
            }
            const localVarPath = `/collections/{collection}/products/{product}/ogcLinks`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"product"}}`, encodeURIComponent(String(product)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates/creates a products OGC links
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductOgcLinksPut: async (collection: string, product: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionProductsProductOgcLinksPut.');
            }
            // verify required parameter 'product' is not null or undefined
            if (product === null || product === undefined) {
                throw new RequiredError('product','Required parameter product was null or undefined when calling collectionsCollectionProductsProductOgcLinksPut.');
            }
            const localVarPath = `/collections/{collection}/products/{product}/ogcLinks`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"product"}}`, encodeURIComponent(String(product)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a product search attributes and OGC links
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductPut: async (collection: string, product: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionProductsProductPut.');
            }
            // verify required parameter 'product' is not null or undefined
            if (product === null || product === undefined) {
                throw new RequiredError('product','Required parameter product was null or undefined when calling collectionsCollectionProductsProductPut.');
            }
            const localVarPath = `/collections/{collection}/products/{product}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"product"}}`, encodeURIComponent(String(product)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the product thumbnail
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductThumbnailDelete: async (collection: string, product: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionProductsProductThumbnailDelete.');
            }
            // verify required parameter 'product' is not null or undefined
            if (product === null || product === undefined) {
                throw new RequiredError('product','Required parameter product was null or undefined when calling collectionsCollectionProductsProductThumbnailDelete.');
            }
            const localVarPath = `/collections/{collection}/products/{product}/thumbnail`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"product"}}`, encodeURIComponent(String(product)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the thumbnail of this product
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductThumbnailGet: async (collection: string, product: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionProductsProductThumbnailGet.');
            }
            // verify required parameter 'product' is not null or undefined
            if (product === null || product === undefined) {
                throw new RequiredError('product','Required parameter product was null or undefined when calling collectionsCollectionProductsProductThumbnailGet.');
            }
            const localVarPath = `/collections/{collection}/products/{product}/thumbnail`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"product"}}`, encodeURIComponent(String(product)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates/creates a product thumbnail
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductThumbnailPut: async (collection: string, product: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionProductsProductThumbnailPut.');
            }
            // verify required parameter 'product' is not null or undefined
            if (product === null || product === undefined) {
                throw new RequiredError('product','Required parameter product was null or undefined when calling collectionsCollectionProductsProductThumbnailPut.');
            }
            const localVarPath = `/collections/{collection}/products/{product}/thumbnail`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"product"}}`, encodeURIComponent(String(product)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a collection search attributes
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionPut: async (collection: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionPut.');
            }
            const localVarPath = `/collections/{collection}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the collection thumbnail
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionThumbnailDelete: async (collection: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionThumbnailDelete.');
            }
            const localVarPath = `/collections/{collection}/thumbnail`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the thumbnail of this collection
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionThumbnailGet: async (collection: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionThumbnailGet.');
            }
            const localVarPath = `/collections/{collection}/thumbnail`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates/creates a collection thumbnail
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionThumbnailPut: async (collection: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling collectionsCollectionThumbnailPut.');
            }
            const localVarPath = `/collections/{collection}/thumbnail`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all available collections (names and links)
         * @param {number} [offset] First element for paged responses
         * @param {number} [limit] Number of elements in page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsGet: async (offset?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/collections`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new collection via its search attributes and ogc links.  The zip format accepts a set of files creating the collection in a single shot, and will contain the following files:  * collection.json: the list of searchable attributes, the format is the same as the one returned by a GET on a collection, the \"*HRef\" properties should be omitted.  * description.html: the HTML description for the collection * metadata.xml: the ISO metadata for the collection * thumbnail.png: the collection thumbnail (ignored at the time of writing) * owsLinks.json: the list of OWS links, in the same JSON format as the associated resource A creation with ZIP is recommend for speed and consistency sake. 
         * @param {boolean} [ogcPublish] When set to true, instructs GeoServer to automatically publish the collection as a layer in the location GeoServer
         * @param {string} [workspace] workspace where the collection will be published (if missing the default workspace will be used)
         * @param {string} [layer] layer name used when publishing the collection (if missing the collection name will be used)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsPost: async (ogcPublish?: boolean, workspace?: string, layer?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/collections`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ogcPublish !== undefined) {
                localVarQueryParameter['ogc_publish'] = ogcPublish;
            }

            if (workspace !== undefined) {
                localVarQueryParameter['workspace'] = workspace;
            }

            if (layer !== undefined) {
                localVarQueryParameter['layer'] = layer;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes a collection and everything inside it
         * @param {string} collection Identifier of the collection
         * @param {boolean} [keepMetadata] When present and set to true, makes GeoServer un-publish the collection (removal of OGC links, removal of associated layer) without removing the metadata. The collection remains searchable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionDelete(collection: string, keepMetadata?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionDelete(collection, keepMetadata, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes the collection HTML description
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionDescriptionDelete(collection: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionDescriptionDelete(collection, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the HTML description of this collection
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionDescriptionGet(collection: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionDescriptionGet(collection, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates/creates a collection HTML description
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionDescriptionPut(collection: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionDescriptionPut(collection, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves a collection search attributes and its ogc links
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionGet(collection: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionGet(collection, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes the mosaic configuration, store, layer and style associated to this collection
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionLayerDelete(collection: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionLayerDelete(collection, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the current publishing configuration for the layer (or 404 if no configuration is currently in use)
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionLayerGet(collection: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionLayerGet(collection, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes the previous publshing configuration and replaces with a new one, creating along the mosaic configuration, store, layer and style as described
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionLayerPut(collection: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionLayerPut(collection, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the list of collection layers
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionLayersGet(collection: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionLayersGet(collection, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes the collection layer configuration
         * @param {string} collection Identifier of the collection
         * @param {string} layer Identifier of the layer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionLayersLayerDelete(collection: string, layer: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionLayersLayerDelete(collection, layer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the list of collection layers
         * @param {string} collection Identifier of the collection
         * @param {string} layer Identifier of the layer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionLayersLayerGet(collection: string, layer: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionLayersLayerGet(collection, layer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates/creates a collection layer publishing configuration
         * @param {string} collection Identifier of the collection
         * @param {string} layer Identifier of the layer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionLayersLayerPut(collection: string, layer: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionLayersLayerPut(collection, layer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes the product metadata
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionMetadataDelete(collection: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionMetadataDelete(collection, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the ISO metadata of this collection
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionMetadataGet(collection: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionMetadataGet(collection, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates/creates a collection ISO metadata
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionMetadataPut(collection: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionMetadataPut(collection, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes the collection OGC links
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionOgcLinksDelete(collection: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionOgcLinksDelete(collection, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the list of OGC links
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionOgcLinksGet(collection: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionOgcLinksGet(collection, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates/creates a collection OGC links
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionOgcLinksPut(collection: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionOgcLinksPut(collection, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a paged list of all available products
         * @param {string} collection Identifier of the collection
         * @param {number} [offset] First element for paged responses
         * @param {number} [limit] Number of elements in page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionProductsGet(collection: string, offset?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionProductsGet(collection, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new product via its search attributes and ogc links. The zip format accepts  a set of files creating the collection in a single shot, and will contain the following files:  * product.json: the list of searchable attributes and eventual OGC links * description.html: the HTML description for the product * metadata.xml: the O&M metadata for the collection * thumbnail.png: the product thumbnail (can also have jpeg or jpg extension) * owsLinks.json: the list of OWS links, in the same JSON format as the associated resource  * granules.json: the list of granules, in the same JSON format as the associated resource The JSON format is the same as the one returned by a GET on an existing product, the \"*Href\" properties should be omitted  
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionProductsPost(collection: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionProductsPost(collection, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes a product and everything inside it
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {boolean} [keepMetadata] When present and set to true, makes GeoServer un-publish the product (removal of OGC links, direct download location and granule references) without removing the metadata. The product remains searchable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionProductsProductDelete(collection: string, product: string, keepMetadata?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionProductsProductDelete(collection, product, keepMetadata, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes the product HTML description
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionProductsProductDescriptionDelete(collection: string, product: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionProductsProductDescriptionDelete(collection, product, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the HTML description of this product
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionProductsProductDescriptionGet(collection: string, product: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionProductsProductDescriptionGet(collection, product, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates/creates a product HTML description
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionProductsProductDescriptionPut(collection: string, product: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionProductsProductDescriptionPut(collection, product, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves a product search attributes, ogc links and granules. The response contains cross links to ogcLinks/metadata/description/thumnail/granules sub-resources, when the same JSON is used o create a new collection the associated can be omitted, or if everything needs to be put in the JSON, the associated representations can be inlined instead (the thumbnail image can be BASE64 encded). A creation with ZIP is recommend. 
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionProductsProductGet(collection: string, product: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionProductsProductGet(collection, product, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes the product OGC links
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionProductsProductGranulesDelete(collection: string, product: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionProductsProductGranulesDelete(collection, product, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the list of a product granules
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionProductsProductGranulesGet(collection: string, product: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionProductsProductGranulesGet(collection, product, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates/creates a product granules
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionProductsProductGranulesPut(collection: string, product: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionProductsProductGranulesPut(collection, product, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes the product metadata
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionProductsProductMetadataDelete(collection: string, product: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionProductsProductMetadataDelete(collection, product, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the O&M metadata of this product
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionProductsProductMetadataGet(collection: string, product: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionProductsProductMetadataGet(collection, product, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates/creates a product O&M metadata
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionProductsProductMetadataPut(collection: string, product: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionProductsProductMetadataPut(collection, product, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes the product OGC links
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionProductsProductOgcLinksDelete(collection: string, product: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionProductsProductOgcLinksDelete(collection, product, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the list of a product OGC links
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionProductsProductOgcLinksGet(collection: string, product: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionProductsProductOgcLinksGet(collection, product, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates/creates a products OGC links
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionProductsProductOgcLinksPut(collection: string, product: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionProductsProductOgcLinksPut(collection, product, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates a product search attributes and OGC links
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionProductsProductPut(collection: string, product: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionProductsProductPut(collection, product, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes the product thumbnail
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionProductsProductThumbnailDelete(collection: string, product: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionProductsProductThumbnailDelete(collection, product, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the thumbnail of this product
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionProductsProductThumbnailGet(collection: string, product: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionProductsProductThumbnailGet(collection, product, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates/creates a product thumbnail
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionProductsProductThumbnailPut(collection: string, product: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionProductsProductThumbnailPut(collection, product, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates a collection search attributes
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionPut(collection: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionPut(collection, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes the collection thumbnail
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionThumbnailDelete(collection: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionThumbnailDelete(collection, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the thumbnail of this collection
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionThumbnailGet(collection: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionThumbnailGet(collection, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates/creates a collection thumbnail
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsCollectionThumbnailPut(collection: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsCollectionThumbnailPut(collection, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves a list of all available collections (names and links)
         * @param {number} [offset] First element for paged responses
         * @param {number} [limit] Number of elements in page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsGet(offset?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsGet(offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new collection via its search attributes and ogc links.  The zip format accepts a set of files creating the collection in a single shot, and will contain the following files:  * collection.json: the list of searchable attributes, the format is the same as the one returned by a GET on a collection, the \"*HRef\" properties should be omitted.  * description.html: the HTML description for the collection * metadata.xml: the ISO metadata for the collection * thumbnail.png: the collection thumbnail (ignored at the time of writing) * owsLinks.json: the list of OWS links, in the same JSON format as the associated resource A creation with ZIP is recommend for speed and consistency sake. 
         * @param {boolean} [ogcPublish] When set to true, instructs GeoServer to automatically publish the collection as a layer in the location GeoServer
         * @param {string} [workspace] workspace where the collection will be published (if missing the default workspace will be used)
         * @param {string} [layer] layer name used when publishing the collection (if missing the collection name will be used)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsPost(ogcPublish?: boolean, workspace?: string, layer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).collectionsPost(ogcPublish, workspace, layer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Deletes a collection and everything inside it
         * @param {string} collection Identifier of the collection
         * @param {boolean} [keepMetadata] When present and set to true, makes GeoServer un-publish the collection (removal of OGC links, removal of associated layer) without removing the metadata. The collection remains searchable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionDelete(collection: string, keepMetadata?: boolean, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionDelete(collection, keepMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the collection HTML description
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionDescriptionDelete(collection: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionDescriptionDelete(collection, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the HTML description of this collection
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionDescriptionGet(collection: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionDescriptionGet(collection, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates/creates a collection HTML description
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionDescriptionPut(collection: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionDescriptionPut(collection, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a collection search attributes and its ogc links
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionGet(collection: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionGet(collection, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the mosaic configuration, store, layer and style associated to this collection
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionLayerDelete(collection: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionLayerDelete(collection, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the current publishing configuration for the layer (or 404 if no configuration is currently in use)
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionLayerGet(collection: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionLayerGet(collection, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the previous publshing configuration and replaces with a new one, creating along the mosaic configuration, store, layer and style as described
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionLayerPut(collection: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionLayerPut(collection, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of collection layers
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionLayersGet(collection: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionLayersGet(collection, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the collection layer configuration
         * @param {string} collection Identifier of the collection
         * @param {string} layer Identifier of the layer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionLayersLayerDelete(collection: string, layer: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionLayersLayerDelete(collection, layer, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of collection layers
         * @param {string} collection Identifier of the collection
         * @param {string} layer Identifier of the layer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionLayersLayerGet(collection: string, layer: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionLayersLayerGet(collection, layer, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates/creates a collection layer publishing configuration
         * @param {string} collection Identifier of the collection
         * @param {string} layer Identifier of the layer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionLayersLayerPut(collection: string, layer: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionLayersLayerPut(collection, layer, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the product metadata
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionMetadataDelete(collection: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionMetadataDelete(collection, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the ISO metadata of this collection
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionMetadataGet(collection: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionMetadataGet(collection, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates/creates a collection ISO metadata
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionMetadataPut(collection: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionMetadataPut(collection, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the collection OGC links
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionOgcLinksDelete(collection: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionOgcLinksDelete(collection, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of OGC links
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionOgcLinksGet(collection: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionOgcLinksGet(collection, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates/creates a collection OGC links
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionOgcLinksPut(collection: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionOgcLinksPut(collection, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paged list of all available products
         * @param {string} collection Identifier of the collection
         * @param {number} [offset] First element for paged responses
         * @param {number} [limit] Number of elements in page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsGet(collection: string, offset?: number, limit?: number, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionProductsGet(collection, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new product via its search attributes and ogc links. The zip format accepts  a set of files creating the collection in a single shot, and will contain the following files:  * product.json: the list of searchable attributes and eventual OGC links * description.html: the HTML description for the product * metadata.xml: the O&M metadata for the collection * thumbnail.png: the product thumbnail (can also have jpeg or jpg extension) * owsLinks.json: the list of OWS links, in the same JSON format as the associated resource  * granules.json: the list of granules, in the same JSON format as the associated resource The JSON format is the same as the one returned by a GET on an existing product, the \"*Href\" properties should be omitted  
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsPost(collection: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionProductsPost(collection, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a product and everything inside it
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {boolean} [keepMetadata] When present and set to true, makes GeoServer un-publish the product (removal of OGC links, direct download location and granule references) without removing the metadata. The product remains searchable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductDelete(collection: string, product: string, keepMetadata?: boolean, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionProductsProductDelete(collection, product, keepMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the product HTML description
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductDescriptionDelete(collection: string, product: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionProductsProductDescriptionDelete(collection, product, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the HTML description of this product
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductDescriptionGet(collection: string, product: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionProductsProductDescriptionGet(collection, product, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates/creates a product HTML description
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductDescriptionPut(collection: string, product: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionProductsProductDescriptionPut(collection, product, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a product search attributes, ogc links and granules. The response contains cross links to ogcLinks/metadata/description/thumnail/granules sub-resources, when the same JSON is used o create a new collection the associated can be omitted, or if everything needs to be put in the JSON, the associated representations can be inlined instead (the thumbnail image can be BASE64 encded). A creation with ZIP is recommend. 
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductGet(collection: string, product: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionProductsProductGet(collection, product, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the product OGC links
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductGranulesDelete(collection: string, product: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionProductsProductGranulesDelete(collection, product, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of a product granules
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductGranulesGet(collection: string, product: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionProductsProductGranulesGet(collection, product, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates/creates a product granules
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductGranulesPut(collection: string, product: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionProductsProductGranulesPut(collection, product, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the product metadata
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductMetadataDelete(collection: string, product: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionProductsProductMetadataDelete(collection, product, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the O&M metadata of this product
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductMetadataGet(collection: string, product: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionProductsProductMetadataGet(collection, product, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates/creates a product O&M metadata
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductMetadataPut(collection: string, product: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionProductsProductMetadataPut(collection, product, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the product OGC links
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductOgcLinksDelete(collection: string, product: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionProductsProductOgcLinksDelete(collection, product, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of a product OGC links
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductOgcLinksGet(collection: string, product: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionProductsProductOgcLinksGet(collection, product, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates/creates a products OGC links
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductOgcLinksPut(collection: string, product: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionProductsProductOgcLinksPut(collection, product, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a product search attributes and OGC links
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductPut(collection: string, product: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionProductsProductPut(collection, product, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the product thumbnail
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductThumbnailDelete(collection: string, product: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionProductsProductThumbnailDelete(collection, product, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the thumbnail of this product
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductThumbnailGet(collection: string, product: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionProductsProductThumbnailGet(collection, product, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates/creates a product thumbnail
         * @param {string} collection Identifier of the collection
         * @param {string} product Identifier of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionProductsProductThumbnailPut(collection: string, product: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionProductsProductThumbnailPut(collection, product, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a collection search attributes
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionPut(collection: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionPut(collection, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the collection thumbnail
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionThumbnailDelete(collection: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionThumbnailDelete(collection, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the thumbnail of this collection
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionThumbnailGet(collection: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionThumbnailGet(collection, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates/creates a collection thumbnail
         * @param {string} collection Identifier of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCollectionThumbnailPut(collection: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsCollectionThumbnailPut(collection, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all available collections (names and links)
         * @param {number} [offset] First element for paged responses
         * @param {number} [limit] Number of elements in page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsGet(offset?: number, limit?: number, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsGet(offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new collection via its search attributes and ogc links.  The zip format accepts a set of files creating the collection in a single shot, and will contain the following files:  * collection.json: the list of searchable attributes, the format is the same as the one returned by a GET on a collection, the \"*HRef\" properties should be omitted.  * description.html: the HTML description for the collection * metadata.xml: the ISO metadata for the collection * thumbnail.png: the collection thumbnail (ignored at the time of writing) * owsLinks.json: the list of OWS links, in the same JSON format as the associated resource A creation with ZIP is recommend for speed and consistency sake. 
         * @param {boolean} [ogcPublish] When set to true, instructs GeoServer to automatically publish the collection as a layer in the location GeoServer
         * @param {string} [workspace] workspace where the collection will be published (if missing the default workspace will be used)
         * @param {string} [layer] layer name used when publishing the collection (if missing the collection name will be used)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsPost(ogcPublish?: boolean, workspace?: string, layer?: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).collectionsPost(ogcPublish, workspace, layer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
    /**
     * Deletes a collection and everything inside it
     * @param {string} collection Identifier of the collection
     * @param {boolean} [keepMetadata] When present and set to true, makes GeoServer un-publish the collection (removal of OGC links, removal of associated layer) without removing the metadata. The collection remains searchable.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionDelete(collection: string, keepMetadata?: boolean, options?: any): AxiosPromise<void>;

    /**
     * Removes the collection HTML description
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionDescriptionDelete(collection: string, options?: any): AxiosPromise<void>;

    /**
     * Returns the HTML description of this collection
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionDescriptionGet(collection: string, options?: any): AxiosPromise<void>;

    /**
     * Updates/creates a collection HTML description
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionDescriptionPut(collection: string, options?: any): AxiosPromise<void>;

    /**
     * Retrieves a collection search attributes and its ogc links
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionGet(collection: string, options?: any): AxiosPromise<void>;

    /**
     * Removes the mosaic configuration, store, layer and style associated to this collection
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionLayerDelete(collection: string, options?: any): AxiosPromise<void>;

    /**
     * Returns the current publishing configuration for the layer (or 404 if no configuration is currently in use)
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionLayerGet(collection: string, options?: any): AxiosPromise<void>;

    /**
     * Removes the previous publshing configuration and replaces with a new one, creating along the mosaic configuration, store, layer and style as described
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionLayerPut(collection: string, options?: any): AxiosPromise<void>;

    /**
     * Returns the list of collection layers
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionLayersGet(collection: string, options?: any): AxiosPromise<void>;

    /**
     * Removes the collection layer configuration
     * @param {string} collection Identifier of the collection
     * @param {string} layer Identifier of the layer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionLayersLayerDelete(collection: string, layer: string, options?: any): AxiosPromise<void>;

    /**
     * Returns the list of collection layers
     * @param {string} collection Identifier of the collection
     * @param {string} layer Identifier of the layer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionLayersLayerGet(collection: string, layer: string, options?: any): AxiosPromise<void>;

    /**
     * Updates/creates a collection layer publishing configuration
     * @param {string} collection Identifier of the collection
     * @param {string} layer Identifier of the layer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionLayersLayerPut(collection: string, layer: string, options?: any): AxiosPromise<void>;

    /**
     * Removes the product metadata
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionMetadataDelete(collection: string, options?: any): AxiosPromise<void>;

    /**
     * Returns the ISO metadata of this collection
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionMetadataGet(collection: string, options?: any): AxiosPromise<void>;

    /**
     * Updates/creates a collection ISO metadata
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionMetadataPut(collection: string, options?: any): AxiosPromise<void>;

    /**
     * Removes the collection OGC links
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionOgcLinksDelete(collection: string, options?: any): AxiosPromise<void>;

    /**
     * Returns the list of OGC links
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionOgcLinksGet(collection: string, options?: any): AxiosPromise<void>;

    /**
     * Updates/creates a collection OGC links
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionOgcLinksPut(collection: string, options?: any): AxiosPromise<void>;

    /**
     * Returns a paged list of all available products
     * @param {string} collection Identifier of the collection
     * @param {number} [offset] First element for paged responses
     * @param {number} [limit] Number of elements in page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionProductsGet(collection: string, offset?: number, limit?: number, options?: any): AxiosPromise<void>;

    /**
     * Creates a new product via its search attributes and ogc links. The zip format accepts  a set of files creating the collection in a single shot, and will contain the following files:  * product.json: the list of searchable attributes and eventual OGC links * description.html: the HTML description for the product * metadata.xml: the O&M metadata for the collection * thumbnail.png: the product thumbnail (can also have jpeg or jpg extension) * owsLinks.json: the list of OWS links, in the same JSON format as the associated resource  * granules.json: the list of granules, in the same JSON format as the associated resource The JSON format is the same as the one returned by a GET on an existing product, the \"*Href\" properties should be omitted  
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionProductsPost(collection: string, options?: any): AxiosPromise<void>;

    /**
     * Deletes a product and everything inside it
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {boolean} [keepMetadata] When present and set to true, makes GeoServer un-publish the product (removal of OGC links, direct download location and granule references) without removing the metadata. The product remains searchable.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionProductsProductDelete(collection: string, product: string, keepMetadata?: boolean, options?: any): AxiosPromise<void>;

    /**
     * Removes the product HTML description
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionProductsProductDescriptionDelete(collection: string, product: string, options?: any): AxiosPromise<void>;

    /**
     * Returns the HTML description of this product
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionProductsProductDescriptionGet(collection: string, product: string, options?: any): AxiosPromise<void>;

    /**
     * Updates/creates a product HTML description
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionProductsProductDescriptionPut(collection: string, product: string, options?: any): AxiosPromise<void>;

    /**
     * Retrieves a product search attributes, ogc links and granules. The response contains cross links to ogcLinks/metadata/description/thumnail/granules sub-resources, when the same JSON is used o create a new collection the associated can be omitted, or if everything needs to be put in the JSON, the associated representations can be inlined instead (the thumbnail image can be BASE64 encded). A creation with ZIP is recommend. 
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionProductsProductGet(collection: string, product: string, options?: any): AxiosPromise<void>;

    /**
     * Removes the product OGC links
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionProductsProductGranulesDelete(collection: string, product: string, options?: any): AxiosPromise<void>;

    /**
     * Returns the list of a product granules
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionProductsProductGranulesGet(collection: string, product: string, options?: any): AxiosPromise<void>;

    /**
     * Updates/creates a product granules
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionProductsProductGranulesPut(collection: string, product: string, options?: any): AxiosPromise<void>;

    /**
     * Removes the product metadata
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionProductsProductMetadataDelete(collection: string, product: string, options?: any): AxiosPromise<void>;

    /**
     * Returns the O&M metadata of this product
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionProductsProductMetadataGet(collection: string, product: string, options?: any): AxiosPromise<void>;

    /**
     * Updates/creates a product O&M metadata
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionProductsProductMetadataPut(collection: string, product: string, options?: any): AxiosPromise<void>;

    /**
     * Removes the product OGC links
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionProductsProductOgcLinksDelete(collection: string, product: string, options?: any): AxiosPromise<void>;

    /**
     * Returns the list of a product OGC links
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionProductsProductOgcLinksGet(collection: string, product: string, options?: any): AxiosPromise<void>;

    /**
     * Updates/creates a products OGC links
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionProductsProductOgcLinksPut(collection: string, product: string, options?: any): AxiosPromise<void>;

    /**
     * Updates a product search attributes and OGC links
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionProductsProductPut(collection: string, product: string, options?: any): AxiosPromise<void>;

    /**
     * Removes the product thumbnail
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionProductsProductThumbnailDelete(collection: string, product: string, options?: any): AxiosPromise<void>;

    /**
     * Returns the thumbnail of this product
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionProductsProductThumbnailGet(collection: string, product: string, options?: any): AxiosPromise<void>;

    /**
     * Updates/creates a product thumbnail
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionProductsProductThumbnailPut(collection: string, product: string, options?: any): AxiosPromise<void>;

    /**
     * Updates a collection search attributes
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionPut(collection: string, options?: any): AxiosPromise<void>;

    /**
     * Removes the collection thumbnail
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionThumbnailDelete(collection: string, options?: any): AxiosPromise<void>;

    /**
     * Returns the thumbnail of this collection
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionThumbnailGet(collection: string, options?: any): AxiosPromise<void>;

    /**
     * Updates/creates a collection thumbnail
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsCollectionThumbnailPut(collection: string, options?: any): AxiosPromise<void>;

    /**
     * Retrieves a list of all available collections (names and links)
     * @param {number} [offset] First element for paged responses
     * @param {number} [limit] Number of elements in page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsGet(offset?: number, limit?: number, options?: any): AxiosPromise<void>;

    /**
     * Creates a new collection via its search attributes and ogc links.  The zip format accepts a set of files creating the collection in a single shot, and will contain the following files:  * collection.json: the list of searchable attributes, the format is the same as the one returned by a GET on a collection, the \"*HRef\" properties should be omitted.  * description.html: the HTML description for the collection * metadata.xml: the ISO metadata for the collection * thumbnail.png: the collection thumbnail (ignored at the time of writing) * owsLinks.json: the list of OWS links, in the same JSON format as the associated resource A creation with ZIP is recommend for speed and consistency sake. 
     * @param {boolean} [ogcPublish] When set to true, instructs GeoServer to automatically publish the collection as a layer in the location GeoServer
     * @param {string} [workspace] workspace where the collection will be published (if missing the default workspace will be used)
     * @param {string} [layer] layer name used when publishing the collection (if missing the collection name will be used)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    collectionsPost(ogcPublish?: boolean, workspace?: string, layer?: string, options?: any): AxiosPromise<void>;

}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
    /**
     * Deletes a collection and everything inside it
     * @param {string} collection Identifier of the collection
     * @param {boolean} [keepMetadata] When present and set to true, makes GeoServer un-publish the collection (removal of OGC links, removal of associated layer) without removing the metadata. The collection remains searchable.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionDelete(collection: string, keepMetadata?: boolean, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionDelete(collection, keepMetadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the collection HTML description
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionDescriptionDelete(collection: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionDescriptionDelete(collection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the HTML description of this collection
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionDescriptionGet(collection: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionDescriptionGet(collection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates/creates a collection HTML description
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionDescriptionPut(collection: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionDescriptionPut(collection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a collection search attributes and its ogc links
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionGet(collection: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionGet(collection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the mosaic configuration, store, layer and style associated to this collection
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionLayerDelete(collection: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionLayerDelete(collection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the current publishing configuration for the layer (or 404 if no configuration is currently in use)
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionLayerGet(collection: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionLayerGet(collection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the previous publshing configuration and replaces with a new one, creating along the mosaic configuration, store, layer and style as described
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionLayerPut(collection: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionLayerPut(collection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of collection layers
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionLayersGet(collection: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionLayersGet(collection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the collection layer configuration
     * @param {string} collection Identifier of the collection
     * @param {string} layer Identifier of the layer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionLayersLayerDelete(collection: string, layer: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionLayersLayerDelete(collection, layer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of collection layers
     * @param {string} collection Identifier of the collection
     * @param {string} layer Identifier of the layer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionLayersLayerGet(collection: string, layer: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionLayersLayerGet(collection, layer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates/creates a collection layer publishing configuration
     * @param {string} collection Identifier of the collection
     * @param {string} layer Identifier of the layer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionLayersLayerPut(collection: string, layer: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionLayersLayerPut(collection, layer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the product metadata
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionMetadataDelete(collection: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionMetadataDelete(collection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the ISO metadata of this collection
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionMetadataGet(collection: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionMetadataGet(collection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates/creates a collection ISO metadata
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionMetadataPut(collection: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionMetadataPut(collection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the collection OGC links
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionOgcLinksDelete(collection: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionOgcLinksDelete(collection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of OGC links
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionOgcLinksGet(collection: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionOgcLinksGet(collection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates/creates a collection OGC links
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionOgcLinksPut(collection: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionOgcLinksPut(collection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paged list of all available products
     * @param {string} collection Identifier of the collection
     * @param {number} [offset] First element for paged responses
     * @param {number} [limit] Number of elements in page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionProductsGet(collection: string, offset?: number, limit?: number, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionProductsGet(collection, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new product via its search attributes and ogc links. The zip format accepts  a set of files creating the collection in a single shot, and will contain the following files:  * product.json: the list of searchable attributes and eventual OGC links * description.html: the HTML description for the product * metadata.xml: the O&M metadata for the collection * thumbnail.png: the product thumbnail (can also have jpeg or jpg extension) * owsLinks.json: the list of OWS links, in the same JSON format as the associated resource  * granules.json: the list of granules, in the same JSON format as the associated resource The JSON format is the same as the one returned by a GET on an existing product, the \"*Href\" properties should be omitted  
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionProductsPost(collection: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionProductsPost(collection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a product and everything inside it
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {boolean} [keepMetadata] When present and set to true, makes GeoServer un-publish the product (removal of OGC links, direct download location and granule references) without removing the metadata. The product remains searchable.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionProductsProductDelete(collection: string, product: string, keepMetadata?: boolean, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionProductsProductDelete(collection, product, keepMetadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the product HTML description
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionProductsProductDescriptionDelete(collection: string, product: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionProductsProductDescriptionDelete(collection, product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the HTML description of this product
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionProductsProductDescriptionGet(collection: string, product: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionProductsProductDescriptionGet(collection, product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates/creates a product HTML description
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionProductsProductDescriptionPut(collection: string, product: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionProductsProductDescriptionPut(collection, product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a product search attributes, ogc links and granules. The response contains cross links to ogcLinks/metadata/description/thumnail/granules sub-resources, when the same JSON is used o create a new collection the associated can be omitted, or if everything needs to be put in the JSON, the associated representations can be inlined instead (the thumbnail image can be BASE64 encded). A creation with ZIP is recommend. 
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionProductsProductGet(collection: string, product: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionProductsProductGet(collection, product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the product OGC links
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionProductsProductGranulesDelete(collection: string, product: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionProductsProductGranulesDelete(collection, product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of a product granules
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionProductsProductGranulesGet(collection: string, product: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionProductsProductGranulesGet(collection, product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates/creates a product granules
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionProductsProductGranulesPut(collection: string, product: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionProductsProductGranulesPut(collection, product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the product metadata
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionProductsProductMetadataDelete(collection: string, product: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionProductsProductMetadataDelete(collection, product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the O&M metadata of this product
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionProductsProductMetadataGet(collection: string, product: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionProductsProductMetadataGet(collection, product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates/creates a product O&M metadata
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionProductsProductMetadataPut(collection: string, product: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionProductsProductMetadataPut(collection, product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the product OGC links
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionProductsProductOgcLinksDelete(collection: string, product: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionProductsProductOgcLinksDelete(collection, product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of a product OGC links
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionProductsProductOgcLinksGet(collection: string, product: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionProductsProductOgcLinksGet(collection, product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates/creates a products OGC links
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionProductsProductOgcLinksPut(collection: string, product: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionProductsProductOgcLinksPut(collection, product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a product search attributes and OGC links
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionProductsProductPut(collection: string, product: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionProductsProductPut(collection, product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the product thumbnail
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionProductsProductThumbnailDelete(collection: string, product: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionProductsProductThumbnailDelete(collection, product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the thumbnail of this product
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionProductsProductThumbnailGet(collection: string, product: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionProductsProductThumbnailGet(collection, product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates/creates a product thumbnail
     * @param {string} collection Identifier of the collection
     * @param {string} product Identifier of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionProductsProductThumbnailPut(collection: string, product: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionProductsProductThumbnailPut(collection, product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a collection search attributes
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionPut(collection: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionPut(collection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the collection thumbnail
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionThumbnailDelete(collection: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionThumbnailDelete(collection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the thumbnail of this collection
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionThumbnailGet(collection: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionThumbnailGet(collection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates/creates a collection thumbnail
     * @param {string} collection Identifier of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsCollectionThumbnailPut(collection: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsCollectionThumbnailPut(collection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all available collections (names and links)
     * @param {number} [offset] First element for paged responses
     * @param {number} [limit] Number of elements in page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsGet(offset?: number, limit?: number, options?: any) {
        return DefaultApiFp(this.configuration).collectionsGet(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new collection via its search attributes and ogc links.  The zip format accepts a set of files creating the collection in a single shot, and will contain the following files:  * collection.json: the list of searchable attributes, the format is the same as the one returned by a GET on a collection, the \"*HRef\" properties should be omitted.  * description.html: the HTML description for the collection * metadata.xml: the ISO metadata for the collection * thumbnail.png: the collection thumbnail (ignored at the time of writing) * owsLinks.json: the list of OWS links, in the same JSON format as the associated resource A creation with ZIP is recommend for speed and consistency sake. 
     * @param {boolean} [ogcPublish] When set to true, instructs GeoServer to automatically publish the collection as a layer in the location GeoServer
     * @param {string} [workspace] workspace where the collection will be published (if missing the default workspace will be used)
     * @param {string} [layer] layer name used when publishing the collection (if missing the collection name will be used)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public collectionsPost(ogcPublish?: boolean, workspace?: string, layer?: string, options?: any) {
        return DefaultApiFp(this.configuration).collectionsPost(ogcPublish, workspace, layer, options).then((request) => request(this.axios, this.basePath));
    }

}


